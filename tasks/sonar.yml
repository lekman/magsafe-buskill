# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: "3"
# SonarCloud Tasks
# This file is self-contained and can be reused in other projects.
# All scripts are embedded inline for maximum portability.
#
# Configuration:
# - Set PROJECT_KEY and ORGANIZATION vars for your project
# - Add SONAR_TOKEN to your .env file
# - Adjust exclusion patterns as needed
vars:
  # Project configuration (inherited from parent Taskfile)
  PROJECT_NAME: '{{.PROJECT_NAME | default "MyProject"}}'
  # Coverage exclusion pattern
  COVERAGE_EXCLUDE: '{{.COVERAGE_EXCLUDE | default ".*Tests\\\\.swift|.*Mocks?\\\\.swift|.*Protocol\\\\.swift"}}'
tasks:
  default:
    desc: List available SonarCloud tasks
    silent: true
    cmds:
      - task --list | grep "^\\* sonar:" | grep -v "::" || true
  scan:
    desc: Run SonarCloud scan locally
    silent: true
    vars:
      REPORT_PATH: "{{.PWD}}/.logs/sonar"
    cmds:
      - |
        #!/bin/bash
        echo "🔍 Running SonarCloud scan locally..."

        # Source .env file if it exists
        if [ -f .env ]; then
          echo "📄 Loading environment variables from .env"
          set -a
          source .env
          set +a
        fi

        # Check if sonar-scanner is installed
        if ! command -v sonar-scanner &> /dev/null; then
          echo "❌ sonar-scanner is not installed"
          echo ""
          echo "To install on macOS:"
          echo "  brew install sonar-scanner"
          echo ""
          echo "To install on Linux:"
          echo "  Download from https://docs.logs/sonar.io/advanced-setup/ci-based-analysis/sonarscanner-cli/"
          echo ""
          echo "Alternative: Use SwiftLint locally for basic code analysis"
          echo ""
          exit 1
        fi

        # Check for SONAR_TOKEN
        if [ -z "$SONAR_TOKEN" ]; then
          echo "❌ SONAR_TOKEN environment variable is not set"
          echo ""
          echo "To run SonarCloud analysis, you need to:"
          echo "1. Get your token from: https://sonarcloud.io/account/security"
          echo "2. Add it to your .env file:"
          echo "   echo 'SONAR_TOKEN=your-token-here' >> .env"
          echo "3. Run this task again"
          echo ""
          echo "Alternative: Run 'task swift:lint' for local code analysis"
          exit 1
        fi

        # Create report directory
        mkdir -p {{.REPORT_PATH}}

        # Check if coverage.xml already exists
        if [ -f "coverage.xml" ]; then
          echo "✅ Found existing coverage.xml - skipping test and conversion steps"
          COVERAGE_SIZE=$(wc -c < coverage.xml)
          COVERAGE_FILES=$(grep -c '<file path=' coverage.xml || echo 0)
          echo "   File size: ${COVERAGE_SIZE} bytes"
          echo "   Files covered: ${COVERAGE_FILES}"
        else
          # Run tests with coverage first
          echo "📊 Generating coverage data..."
          task swift:test

          # Convert coverage to SonarQube format
          echo "🔄 Converting coverage to SonarQube format..."
          task sonar:convert

          # Check if coverage files exist after generation
          if [ ! -f "coverage.xml" ]; then
            echo "⚠️  No coverage.xml found. Running scan without coverage data."
          fi
        fi

        # Run sonar-scanner with performance optimizations
        echo "🚀 Running SonarCloud analysis..."
        echo "📊 Scanning only Swift source files in Sources/ and Tests/"

        # Full analysis with upload to SonarCloud and performance optimizations
        sonar-scanner \
          -Dsonar.host.url=https://sonarcloud.io \
          -Dsonar.token=$SONAR_TOKEN \
          -Dsonar.scanner.metadataFilePath={{.REPORT_PATH}}/report-task.txt \
          -Dsonar.working.directory={{.REPORT_PATH}}/.scannerwork \
          2>&1 | tee {{.REPORT_PATH}}/sonar-scanner.log

        # Check result (capture exit code before it's lost)
        SCAN_RESULT=$?

        # Extract issues from the scan log to create findings file
        echo ""
        echo "📋 Extracting findings from scan log..."

        # Create findings file from the scanner log
        if [ -f "{{.REPORT_PATH}}/sonar-scanner.log" ]; then
          {
            echo "=== SonarCloud Findings Report ==="
            echo "Generated: $(date)"
            echo "Project: lekman_magsafe-buskill"
            echo ""

            # Extract quality gate status
            QUALITY_GATE=$(grep "QUALITY GATE STATUS:" {{.REPORT_PATH}}/sonar-scanner.log | head -1 || echo "")
            if [ -n "$QUALITY_GATE" ]; then
              echo "$QUALITY_GATE"
              echo ""
            fi

            # Extract issues from the log (these appear during analysis)
            echo "===================================================="
            echo "ISSUES FOUND DURING ANALYSIS"
            echo "===================================================="
            echo ""

            # Look for Swift file issues in the log
            grep -E "(ERROR|WARN|INFO).*Sources.*\\.swift" {{.REPORT_PATH}}/sonar-scanner.log | while read -r line; do
              echo "[CODE_SMELL] $line"
              echo "  Status: OPEN"
              echo ""
            done

            # If no issues found in log, create placeholder
            if ! grep -q -E "(ERROR|WARN|INFO).*Sources.*\\.swift" {{.REPORT_PATH}}/sonar-scanner.log; then
              echo "No issues found in scan log."
              echo "For detailed analysis results, view online at:"
              echo "https://sonarcloud.io/summary/overall?id=lekman_magsafe-buskill"
            fi

          } > {{.REPORT_PATH}}/sonarcloud-findings.txt

          echo "✅ Findings extracted to {{.REPORT_PATH}}/sonarcloud-findings.txt"
        fi

        # Show any open issues as warnings
        if [ -f "{{.REPORT_PATH}}/sonarcloud-findings.txt" ]; then
          OPEN_ISSUES=$(grep -c "Status: OPEN\\|Status: CONFIRMED\\|Status: REOPENED" {{.REPORT_PATH}}/sonarcloud-findings.txt 2>/dev/null || echo 0)
          if [ $OPEN_ISSUES -gt 0 ]; then
            echo ""
            echo "⚠️  Found $OPEN_ISSUES open issues:"
            echo "─────────────────────────────"
            # Show first 5 open issues with their details
            awk '
              /^\\[CODE_SMELL\\]/ {
                issue = $0
                getline
                rule = $0
                getline
                msg = $0
                if (getline && /Status: (OPEN|CONFIRMED|REOPENED)/) {
                  count++
                  if (count <= 5) {
                    print issue
                    print "  " msg
                    print ""
                  }
                }
              }
            ' {{.REPORT_PATH}}/sonarcloud-findings.txt

            if [ $OPEN_ISSUES -gt 5 ]; then
              echo "... and $((OPEN_ISSUES - 5)) more open issues"
            fi
            echo "─────────────────────────────"
          fi
        fi

        if [ $SCAN_RESULT -eq 0 ]; then
          echo ""
          echo "✅ SonarCloud scan completed successfully"
          echo ""
          echo "Results saved to:"
          echo "  - Log: {{.REPORT_PATH}}/sonar-scanner.log"
          echo "  - Findings: {{.REPORT_PATH}}/sonarcloud-findings.txt"
          echo "  - View online: https://sonarcloud.io/summary/overall?id=lekman_magsafe-buskill"

          # Open the findings file in VSCode
          echo ""
          echo "📂 Opening findings report in VSCode..."
          code {{.REPORT_PATH}}/sonarcloud-findings.txt

          exit 0
        else
          echo ""
          echo "❌ SonarCloud scan failed"
          echo "Check {{.REPORT_PATH}}/sonar-scanner.log for details"

          # Still try to open findings if they exist
          if [ -f "{{.REPORT_PATH}}/sonarcloud-findings.txt" ]; then
            code {{.REPORT_PATH}}/sonarcloud-findings.txt
          fi

          exit 1
        fi

  issues:
    desc: Display SonarCloud findings from previous scan
    silent: true
    vars:
      REPORT_PATH: "{{.PWD}}/.logs/sonar"
    cmds:
      - |
        echo "📋 Checking for SonarCloud findings..."

        FINDINGS_FILE="{{.REPORT_PATH}}/sonarcloud-findings.txt"
        LOG_FILE="{{.REPORT_PATH}}/sonar-scanner.log"

        # Check if findings file exists
        if [ -f "$FINDINGS_FILE" ]; then
          echo "✅ Found findings report"
          echo ""

          # Show summary
          TOTAL_ISSUES=$(grep -c "^\\[CODE_SMELL\\]" "$FINDINGS_FILE" 2>/dev/null || echo 0)
          OPEN_ISSUES=$(grep -c "Status: OPEN\\|Status: CONFIRMED\\|Status: REOPENED" "$FINDINGS_FILE" 2>/dev/null || echo 0)
          CLOSED_ISSUES=$(grep -c "Status: CLOSED" "$FINDINGS_FILE" 2>/dev/null || echo 0)

          echo "📊 Summary:"
          echo "  - Total issues: $TOTAL_ISSUES"
          echo "  - Open issues: $OPEN_ISSUES"
          echo "  - Closed issues: $CLOSED_ISSUES"
          echo ""

          # Show open issues
          if [ $OPEN_ISSUES -gt 0 ]; then
            echo "⚠️  Open Issues:"
            echo "─────────────────────────────"
            awk '
              /^\\[CODE_SMELL\\]/ {
                issue = $0
                getline
                rule = $0
                getline
                msg = $0
                if (getline && /Status: (OPEN|CONFIRMED|REOPENED)/) {
                  print issue
                  print "  " msg
                  print ""
                }
              }
            ' "$FINDINGS_FILE" | head -30
            echo "─────────────────────────────"
          else
            echo "✅ No open issues!"
          fi

          echo ""
          echo "📂 Opening full report in VSCode..."
          code "$FINDINGS_FILE"

        elif [ -f "$LOG_FILE" ]; then
          echo "⚠️  No findings report found, but scan log exists"
          echo ""
          echo "The scan may have been interrupted or failed to generate findings."
          echo "Try running: task sonar:download"
          echo ""
          echo "Log file: $LOG_FILE"
        else
          echo "❌ No SonarCloud scan results found"
          echo ""
          echo "To generate findings:"
          echo "  1. Run a local scan: task sonar:scan"
          echo "  2. Or download from SonarCloud: task sonar:download"
          echo ""
          echo "Note: Local scan requires sonar-scanner to be installed"
          echo "      Download requires SONAR_TOKEN in your .env file"
        fi

  download:
    desc: Download all SonarCloud findings to a local file
    silent: true
    vars:
      REPORT_PATH: .logs/sonar
      PROJECT_KEY: lekman_magsafe-buskill
    cmds:
      - |
        echo "📥 Downloading SonarCloud findings..."

        # Source .env file if it exists
        if [ -f .env ]; then
          set -a
          source .env
          set +a
        fi

        # Check for SONAR_TOKEN
        if [ -z "$SONAR_TOKEN" ]; then
          echo "❌ SONAR_TOKEN environment variable is not set"
          echo ""
          echo "To download SonarCloud findings, you need to:"
          echo "1. Get your token from: https://sonarcloud.io/account/security"
          echo "2. Add it to your .env file:"
          echo "   echo 'SONAR_TOKEN=your-token-here' >> .env"
          echo "3. Run this task again"
          exit 1
        fi

        # Create report directory
        mkdir -p {{.REPORT_PATH}}

        # Download issues from SonarCloud API
        echo "🔍 Fetching issues from SonarCloud..."

        # Fetch all issues (pagination handled)
        PAGE=1
        TOTAL_PAGES=1
        > {{.REPORT_PATH}}/sonarcloud-issues.json

        while [ $PAGE -le $TOTAL_PAGES ]; do
          echo "  Fetching page $PAGE..."

          RESPONSE=$(curl -s -X GET \
            "https://sonarcloud.io/api/issues/search?componentKeys={{.PROJECT_KEY}}&p=$PAGE&ps=500" \
            -H "Authorization: Bearer $SONAR_TOKEN")

          # Check if request was successful
          if [ $? -ne 0 ] || [ -z "$RESPONSE" ]; then
            echo "❌ Failed to fetch issues from SonarCloud"
            exit 1
          fi

          # Extract total pages on first iteration
          if [ $PAGE -eq 1 ]; then
            TOTAL_PAGES=$(echo "$RESPONSE" | python3 -c "import json,sys,math; data=json.load(sys.stdin); print(math.ceil(data.get('paging',{}).get('total',0)/500))" 2>/dev/null || echo "1")
            echo "$RESPONSE" > {{.REPORT_PATH}}/sonarcloud-issues.json
          else
            # Append issues from subsequent pages
            echo "$RESPONSE" | python3 -c "import json,sys; data=json.load(sys.stdin); f=open('{{.REPORT_PATH}}/sonarcloud-issues.json','r+'); existing=json.load(f); existing['issues'].extend(data.get('issues',[])); f.seek(0); json.dump(existing,f,indent=2); f.truncate(); f.close()" 2>/dev/null || true
          fi

          PAGE=$((PAGE + 1))
        done

        # Generate human-readable report
        echo "📝 Generating readable report..."

        # Create temp Python script for processing
        cat > {{.REPORT_PATH}}/process_issues.py << 'SCRIPT_EOF'
        import json
        import sys
        from datetime import datetime

        report_path = '.logs/sonar'
        project_key = 'lekman_magsafe-buskill'

        try:
            with open(f'{report_path}/sonarcloud-issues.json', 'r') as f:
                data = json.load(f)

            issues = data.get('issues', [])

            # Generate report
            with open(f'{report_path}/sonarcloud-findings.txt', 'w') as report:
                report.write(f'=== SonarCloud Findings Report ===\
        ')
                report.write(f'Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}\
        ')
                report.write(f'Project: {project_key}\
        ')
                report.write(f'Total issues: {len(issues)}\
        \
        ')

                # Group by severity
                by_severity = {}
                for issue in issues:
                    severity = issue.get('severity', 'UNKNOWN')
                    if severity not in by_severity:
                        by_severity[severity] = []
                    by_severity[severity].append(issue)

                # Write issues by severity
                for severity in ['BLOCKER', 'CRITICAL', 'MAJOR', 'MINOR', 'INFO']:
                    if severity not in by_severity:
                        continue

                    report.write(f'\
        {"=" * 50}\
        ')
                    report.write(f'{severity} ISSUES ({len(by_severity[severity])})\
        ')
                    report.write(f'{"=" * 50}\
        \
        ')

                    for issue in by_severity[severity]:
                        component = issue.get('component', 'unknown').replace(f'{project_key}:', '')
                        line = issue.get('textRange', {}).get('startLine', 0)

                        report.write(f'[{issue.get("type", "UNKNOWN")}] {component}:{line}\
        ')
                        report.write(f'  Rule: {issue.get("rule", "unknown")}\
        ')
                        report.write(f'  Message: {issue.get("message", "No message")}\
        ')

                        # Add effort if available
                        effort = issue.get('effort')
                        if effort:
                            report.write(f'  Effort: {effort}\
        ')

                        # Add status
                        status = issue.get('status', 'OPEN')
                        if status != 'OPEN':
                            report.write(f'  Status: {status}\
        ')

                        report.write('\
        ')

            print(f'✅ Successfully processed {len(issues)} issues')

        except Exception as e:
            print(f'Error processing SonarCloud response: {e}')
            sys.exit(1)
        SCRIPT_EOF

        python3 {{.REPORT_PATH}}/process_issues.py || exit 1
        rm -f {{.REPORT_PATH}}/process_issues.py

        echo ""
        echo "📊 Summary:"

        # Create temp Python script for summary
        cat > {{.REPORT_PATH}}/summary.py << 'SCRIPT_EOF'
        import json
        import sys

        report_path = '.logs/sonar'

        with open(f'{report_path}/sonarcloud-issues.json', 'r') as f:
            data = json.load(f)
            issues = data.get('issues', [])

            # Count by type
            types = {}
            severities = {}
            for issue in issues:
                issue_type = issue.get('type', 'UNKNOWN')
                severity = issue.get('severity', 'UNKNOWN')
                types[issue_type] = types.get(issue_type, 0) + 1
                severities[severity] = severities.get(severity, 0) + 1

            print('By Type:')
            for t, count in sorted(types.items()):
                print(f'  - {t}: {count}')

            print('\
        By Severity:')
            for s in ['BLOCKER', 'CRITICAL', 'MAJOR', 'MINOR', 'INFO']:
                if s in severities:
                    print(f'  - {s}: {severities[s]}')
        SCRIPT_EOF

        python3 {{.REPORT_PATH}}/summary.py
        rm -f {{.REPORT_PATH}}/summary.py

        echo ""
        echo "✅ Download completed"
        echo ""
        echo "Results saved to:"
        echo "  - Full JSON: {{.REPORT_PATH}}/sonarcloud-issues.json"
        echo "  - Readable report: {{.REPORT_PATH}}/sonarcloud-findings.txt"
        echo ""
        echo "To view the report: cat {{.REPORT_PATH}}/sonarcloud-findings.txt | less"

  download:pr:
    desc: Download SonarCloud pull request report (use PR=123 to specify PR number)
    silent: true
    vars:
      REPORT_PATH: .logs/sonar
      PROJECT_KEY: lekman_magsafe-buskill
      ORGANIZATION: lekman
      SONAR_API_BASE: https://sonarcloud.io/api
    cmds:
      - |
        echo "📥 Downloading SonarCloud pull request report..."

        # Show usage if help is requested
        if [ "${PR}" = "help" ] || [ "${PR}" = "--help" ]; then
          echo ""
          echo "Usage:"
          echo "  task sonar:download:pr         # Interactive mode - choose from list"
          echo "  PR=123 task sonar:download:pr  # Download specific PR"
          echo "  PR=latest task sonar:download:pr  # Download latest PR (non-interactive)"
          echo ""
          exit 0
        fi

        # Source .env file if it exists
        if [ -f .env ]; then
          set -a
          source .env
          set +a
        fi

        # Check for SONAR_TOKEN
        if [ -z "$SONAR_TOKEN" ]; then
          echo "❌ SONAR_TOKEN environment variable is not set"
          echo ""
          echo "To download SonarCloud findings, you need to:"
          echo "1. Get your token from: https://sonarcloud.io/account/security"
          echo "2. Add it to your .env file:"
          echo "   echo 'SONAR_TOKEN=your-token-here' >> .env"
          echo "3. Run this task again"
          exit 1
        fi

        # Get current branch for reference
        CURRENT_BRANCH=$(git branch --show-current)

        # Get PR number from CLI args or try to detect
        PR_NUMBER="${PR:-}"
        PR_TITLE=""
        PR_BRANCH=""

        # First, list all pull requests
        echo "📋 Fetching pull requests from SonarCloud..."
        PR_LIST=$(curl -s -X GET \
          "{{.SONAR_API_BASE}}/project_pull_requests/list?project={{.PROJECT_KEY}}" \
          -H "Authorization: Bearer $SONAR_TOKEN")

        if [ $? -ne 0 ] || [ -z "$PR_LIST" ]; then
          echo "❌ Failed to fetch pull request list"
          exit 1
        fi

        # Handle "latest" keyword
        if [ "$PR_NUMBER" = "latest" ]; then
          PR_NUMBER=$(echo "$PR_LIST" | jq -r '.pullRequests[0].key' 2>/dev/null || echo "")
          if [ -n "$PR_NUMBER" ]; then
            echo "📌 Using latest PR: #$PR_NUMBER"
          else
            echo "❌ No pull requests found"
            exit 1
          fi
        elif [ -z "$PR_NUMBER" ]; then
          echo "🔍 Current git branch: $CURRENT_BRANCH"

          # Display available PRs
          echo ""
          echo "Available pull requests:"
          echo "$PR_LIST" | jq -r '.pullRequests[] | "  PR #\(.key): \(.title) [\(.status)]"' 2>/dev/null || echo "  Unable to parse PR list"

          echo ""
          echo "Enter PR number, 'latest' for most recent, or press Enter to choose latest:"
          read -p "PR selection: " PR_NUMBER

          # If still empty or "latest", get the latest PR
          if [ -z "$PR_NUMBER" ] || [ "$PR_NUMBER" = "latest" ]; then
            PR_NUMBER=$(echo "$PR_LIST" | jq -r '.pullRequests[0].key' 2>/dev/null || echo "")
            if [ -n "$PR_NUMBER" ]; then
              echo "📌 Using latest PR: #$PR_NUMBER"
            else
              echo "❌ No pull requests found"
              exit 1
            fi
          fi
        else
          echo "📌 Using specified PR: #$PR_NUMBER"
        fi

        # Extract PR details
        PR_DATA=$(echo "$PR_LIST" | jq -r ".pullRequests[] | select(.key == \"$PR_NUMBER\")" 2>/dev/null)
        if [ -n "$PR_DATA" ]; then
          PR_TITLE=$(echo "$PR_DATA" | jq -r '.title' 2>/dev/null || echo "")
          PR_BRANCH=$(echo "$PR_DATA" | jq -r '.branch' 2>/dev/null || echo "")
        fi

        # Create report directory
        mkdir -p {{.REPORT_PATH}}

        echo "🔍 Fetching PR #$PR_NUMBER analysis..."

        # Function to make API calls
        api_call() {
          local endpoint="$1"
          curl -s -H "Authorization: Bearer $SONAR_TOKEN" "{{.SONAR_API_BASE}}/$endpoint"
        }

        # Get PR issues
        echo "📋 Fetching PR issues..."
        ISSUES_DATA=$(api_call "issues/search?pullRequest=$PR_NUMBER&componentKeys={{.PROJECT_KEY}}&resolved=false")
        echo "$ISSUES_DATA" > "{{.REPORT_PATH}}/pr-$PR_NUMBER-issues.json"

        # Get PR measures
        echo "📊 Fetching PR measures..."
        MEASURES_DATA=$(api_call "measures/component?component={{.PROJECT_KEY}}&pullRequest=$PR_NUMBER&metricKeys=bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density")
        echo "$MEASURES_DATA" > "{{.REPORT_PATH}}/pr-$PR_NUMBER-measures.json"

        # Process to Markdown
        echo "📝 Generating markdown report..."

        # Extract data for report
        TOTAL_ISSUES=$(echo "$ISSUES_DATA" | jq -r '.total' 2>/dev/null || echo "0")
        BUGS=$(echo "$MEASURES_DATA" | jq -r '.component.measures[] | select(.metric == "bugs") | .value' 2>/dev/null || echo "N/A")
        VULNERABILITIES=$(echo "$MEASURES_DATA" | jq -r '.component.measures[] | select(.metric == "vulnerabilities") | .value' 2>/dev/null || echo "N/A")
        CODE_SMELLS=$(echo "$MEASURES_DATA" | jq -r '.component.measures[] | select(.metric == "code_smells") | .value' 2>/dev/null || echo "N/A")
        COVERAGE=$(echo "$MEASURES_DATA" | jq -r '.component.measures[] | select(.metric == "coverage") | .value' 2>/dev/null || echo "N/A")
        DUPLICATION=$(echo "$MEASURES_DATA" | jq -r '.component.measures[] | select(.metric == "duplicated_lines_density") | .value' 2>/dev/null || echo "N/A")

        # Create markdown report using echo to avoid YAML parsing issues
        {
          echo "# SonarCloud Analysis Report"
          echo ""
          echo "**Project:** {{.PROJECT_KEY}}  "
          echo "**Organization:** {{.ORGANIZATION}}  "
          echo "**Pull Request:** #$PR_NUMBER${PR_TITLE:+ - $PR_TITLE}  "
          echo "**Branch:** ${PR_BRANCH:-Unknown}  "
          echo "**Current Git Branch:** $CURRENT_BRANCH  "
          echo "**Generated:** $(date)  "
          echo ""
          echo "## Quality Metrics"
          echo ""
          echo "| Metric | Value |"
          echo "|--------|-------|"
          echo "| 🐛 Bugs | $BUGS |"
          echo "| 🔒 Vulnerabilities | $VULNERABILITIES |"
          echo "| 🌫️ Code Smells | $CODE_SMELLS |"
          echo "| 📊 Coverage | ${COVERAGE}% |"
          echo "| 📋 Duplication | ${DUPLICATION}% |"
          echo ""
          echo "## Issues ($TOTAL_ISSUES)"
          echo ""
        } > "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"

        if [[ "$TOTAL_ISSUES" -gt 0 ]]; then
          echo "### By Severity" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
          echo "" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"

          for severity in BLOCKER CRITICAL MAJOR MINOR INFO; do
            COUNT=$(echo "$ISSUES_DATA" | jq -r ".issues[] | select(.severity == \"$severity\") | .key" 2>/dev/null | wc -l | tr -d ' ')
            if [[ "$COUNT" -gt 0 ]]; then
              echo "- **$severity**: $COUNT issues" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
            fi
          done

          echo "" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
          echo "### Issue Details" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
          echo "" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"

          # List issues (limit to first 50)
          echo "$ISSUES_DATA" | jq -r '.issues[] | "- **\(.severity)** [\(.rule)](https://rules.sonarsource.com/swift/RSPEC-\(.rule | split(":")[1])): \(.message) (`\(.component | split(":")[1]):\(.line)`)"' 2>/dev/null | head -50 >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md" || true

          REMAINING=$((TOTAL_ISSUES - 50))
          if [[ $REMAINING -gt 0 ]]; then
            echo "" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
            echo "*... and $REMAINING more issues*" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
          fi
        else
          echo "*No issues found! 🎉*" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
        fi

        echo "" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
        echo "---" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
        echo "[View full report on SonarCloud](https://sonarcloud.io/pullrequests/overview?id={{.PROJECT_KEY}}&pullRequest=$PR_NUMBER)" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"

        echo ""
        echo "✅ PR report downloaded"
        echo ""
        echo "Results saved to:"
        echo "  - Markdown report: {{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
        echo "  - Issues JSON: {{.REPORT_PATH}}/pr-$PR_NUMBER-issues.json"
        echo "  - Measures JSON: {{.REPORT_PATH}}/pr-$PR_NUMBER-measures.json"
        echo ""
        echo "📂 Opening report in VSCode..."
        code "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"

  convert:
    desc: Convert Swift coverage to SonarQube generic XML format
    silent: true
    cmds:
      - |
        echo "🔄 Converting Swift coverage to SonarQube format..."

        # Check if coverage.xml already exists
        if [ -f "coverage.xml" ]; then
          echo "✅ coverage.xml already exists - no conversion needed"
          exit 0
        fi

        # Check if we have coverage data from SPM tests
        if [ ! -f "coverage.lcov" ]; then
          echo "❌ No coverage.lcov file found"
          echo "   Run 'task swift:test' first to generate coverage data"
          exit 1
        fi

        # Convert LCOV to SonarQube Generic Test Coverage XML format
        echo "📊 Converting LCOV to SonarQube XML format..."

        # Create proper SonarQube Generic Test Coverage XML
        echo '<?xml version="1.0" encoding="UTF-8"?>' > coverage.xml
        echo '<coverage version="1">' >> coverage.xml

        if [ -s coverage.lcov ]; then
          # Parse LCOV and generate SonarQube XML
          awk '
            BEGIN { 
              current_file = ""
              in_file = 0
            }
            /^SF:/ {
              # Close previous file if open
              if (in_file) {
                print "  </file>"
              }
              # Extract filename and make it relative from MagSafeGuardLib
              file = substr($0, 4)
              gsub(/.*MagSafeGuardLib\//, "MagSafeGuardLib/", file)
              # Skip test files
              if (file !~ /Tests\//) {
                print "  <file path=\"" file "\">"
                in_file = 1
                current_file = file
              } else {
                in_file = 0
                current_file = ""
              }
            }
            /^DA:/ && in_file {
              # Extract line number and hit count
              split(substr($0, 4), parts, ",")
              line_num = parts[1]
              hit_count = parts[2]
              covered = (hit_count > 0) ? "true" : "false"
              print "    <lineToCover lineNumber=\"" line_num "\" covered=\"" covered "\"/>"
            }
            /^end_of_record/ && in_file {
              print "  </file>"
              in_file = 0
              current_file = ""
            }
            END {
              # Close last file if still open
              if (in_file) {
                print "  </file>"
              }
            }
          ' coverage.lcov >> coverage.xml
        else
          echo "⚠️  No coverage.lcov found - creating empty coverage report"
        fi

        echo '</coverage>' >> coverage.xml

        # Validate and report
        if xmllint --noout coverage.xml 2>/dev/null; then
          echo "✅ Generated valid coverage.xml"
        else
          echo "⚠️  Generated coverage.xml (may have validation warnings)"
        fi
        echo "   File size: $(wc -c < coverage.xml) bytes"
        echo "   Files covered: $(grep -c '<file path=' coverage.xml 2>/dev/null || echo 0)"

  setup:
    desc: Setup SonarCloud scanner
    silent: true
    cmds:
      - |
        echo "🔧 Setting up SonarCloud scanner..."

        # Check if already installed
        if command -v sonar-scanner &> /dev/null; then
          echo "✅ sonar-scanner already installed ($(sonar-scanner -v | grep -oE '[0-9]+\\.[0-9]+\\.[0-9]+' | head -1))"

          # Check for updates on macOS
          if command -v brew &> /dev/null && brew list sonar-scanner &>/dev/null; then
            if brew outdated | grep -q "^sonar-scanner"; then
              echo "📦 Updating sonar-scanner..."
              brew upgrade sonar-scanner
            fi
          fi
          exit 0
        fi

        # Detect OS for fresh installation
        OS=$(uname -s | tr '[:upper:]' '[:lower:]')

        if [ "$OS" = "darwin" ]; then
          # macOS
          if command -v brew &> /dev/null; then
            echo "📦 Installing via Homebrew..."
            brew install sonar-scanner
          else
            echo "❌ Homebrew not found. Please install Homebrew first:"
            echo "   /bin/bash -c \\"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\\""
            exit 1
          fi
        elif [ "$OS" = "linux" ]; then
          # Linux
          echo "📦 Installing SonarCloud scanner for Linux..."

          # Check if running in CI or local
          if [ -n "$CI" ] || [ ! -w "/usr/local" ]; then
            # Download to local directory
            INSTALL_DIR="$HOME/.local/bin"
            mkdir -p "$INSTALL_DIR"

            echo "⬇️  Downloading sonar-scanner..."
            curl -sSL https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-4.8.0.2856-linux.zip -o /tmp/sonar-scanner.zip

            echo "📂 Extracting..."
            unzip -q /tmp/sonar-scanner.zip -d /tmp/
            mv /tmp/sonar-scanner-*/* "$INSTALL_DIR/"
            rm -rf /tmp/sonar-scanner*

            echo "✅ Installed to $INSTALL_DIR"
            echo "⚠️  Make sure $INSTALL_DIR is in your PATH"
          else
            # System-wide install
            echo "⬇️  Downloading sonar-scanner..."
            curl -sSL https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-4.8.0.2856-linux.zip -o /tmp/sonar-scanner.zip

            echo "📂 Extracting..."
            sudo unzip -q /tmp/sonar-scanner.zip -d /opt/
            sudo ln -sf /opt/sonar-scanner-*/bin/sonar-scanner /usr/local/bin/sonar-scanner
            rm /tmp/sonar-scanner.zip

            echo "✅ Installed system-wide"
          fi
        else
          echo "❌ Unsupported OS: $OS"
          echo "Please install manually from:"
          echo "https://docs.logs/sonar.io/advanced-setup/ci-based-analysis/sonarscanner-cli/"
          exit 1
        fi

        # Verify installation
        if command -v sonar-scanner &> /dev/null; then
          echo ""
          echo "✅ SonarCloud scanner installed successfully!"
          sonar-scanner -v
        else
          echo "⚠️  Installation completed but sonar-scanner not found in PATH"
          echo "You may need to restart your terminal or add the installation directory to PATH"
        fi
