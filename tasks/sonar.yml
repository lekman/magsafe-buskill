# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: "3"
# SonarCloud Tasks
# This file is self-contained and can be reused in other projects.
# All scripts are embedded inline for maximum portability.
#
# Configuration:
# - Set PROJECT_KEY and ORGANIZATION vars for your project
# - Add SONAR_TOKEN to your .env file
# - Adjust exclusion patterns as needed
vars:
  # Project configuration (inherited from parent Taskfile)
  PROJECT_NAME: '{{.PROJECT_NAME | default "MyProject"}}'
  # Coverage exclusion pattern
  COVERAGE_EXCLUDE: '{{.COVERAGE_EXCLUDE | default ".*Tests\\\\.swift|.*Mocks?\\\\.swift|.*Protocol\\\\.swift"}}'
tasks:
  default:
    desc: List available SonarCloud tasks
    silent: true
    cmds:
      - task --list | grep "^\\* sonar:" | grep -v "::" || true
  scan:
    desc: Run SonarCloud scan locally
    silent: true
    vars:
      REPORT_PATH: "{{.PWD}}/.sonarcloud"
    cmds:
      - |
        #!/bin/bash
        echo "ğŸ” Running SonarCloud scan locally..."

        # Source .env file if it exists
        if [ -f .env ]; then
          echo "ğŸ“„ Loading environment variables from .env"
          set -a
          source .env
          set +a
        fi

        # Check if sonar-scanner is installed
        if ! command -v sonar-scanner &> /dev/null; then
          echo "âŒ sonar-scanner is not installed"
          echo ""
          echo "To install on macOS:"
          echo "  brew install sonar-scanner"
          echo ""
          echo "To install on Linux:"
          echo "  Download from https://docs.sonarcloud.io/advanced-setup/ci-based-analysis/sonarscanner-cli/"
          echo ""
          echo "Alternative: Use SwiftLint locally for basic code analysis"
          echo ""
          exit 1
        fi

        # Check for SONAR_TOKEN
        if [ -z "$SONAR_TOKEN" ]; then
          echo "âŒ SONAR_TOKEN environment variable is not set"
          echo ""
          echo "To run SonarCloud analysis, you need to:"
          echo "1. Get your token from: https://sonarcloud.io/account/security"
          echo "2. Add it to your .env file:"
          echo "   echo 'SONAR_TOKEN=your-token-here' >> .env"
          echo "3. Run this task again"
          echo ""
          echo "Alternative: Run 'task swift:lint' for local code analysis"
          exit 1
        fi

        # Create report directory
        mkdir -p {{.REPORT_PATH}}

        # Check if coverage.xml already exists
        if [ -f "coverage.xml" ]; then
          echo "âœ… Found existing coverage.xml - skipping test and conversion steps"
          COVERAGE_SIZE=$(wc -c < coverage.xml)
          COVERAGE_FILES=$(grep -c '<file path=' coverage.xml || echo 0)
          echo "   File size: ${COVERAGE_SIZE} bytes"
          echo "   Files covered: ${COVERAGE_FILES}"
        else
          # Run tests with coverage first
          echo "ğŸ“Š Generating coverage data..."
          task swift:test

          # Convert coverage to SonarQube format
          echo "ğŸ”„ Converting coverage to SonarQube format..."
          task sonar:convert

          # Check if coverage files exist after generation
          if [ ! -f "coverage.xml" ]; then
            echo "âš ï¸  No coverage.xml found. Running scan without coverage data."
          fi
        fi

        # Run sonar-scanner with performance optimizations
        echo "ğŸš€ Running SonarCloud analysis..."
        echo "ğŸ“Š Scanning only Swift source files in Sources/ and Tests/"

        # Full analysis with upload to SonarCloud and performance optimizations
        sonar-scanner \
          -Dsonar.host.url=https://sonarcloud.io \
          -Dsonar.token=$SONAR_TOKEN \
          -Dsonar.scanner.metadataFilePath={{.REPORT_PATH}}/report-task.txt \
          -Dsonar.working.directory={{.REPORT_PATH}}/.scannerwork \
          2>&1 | tee {{.REPORT_PATH}}/sonar-scanner.log

        # Check result (capture exit code before it's lost)
        SCAN_RESULT=$?

        # Extract issues from the scan log to create findings file
        echo ""
        echo "ğŸ“‹ Extracting findings from scan log..."

        # Create findings file from the scanner log
        if [ -f "{{.REPORT_PATH}}/sonar-scanner.log" ]; then
          {
            echo "=== SonarCloud Findings Report ==="
            echo "Generated: $(date)"
            echo "Project: lekman_magsafe-buskill"
            echo ""

            # Extract quality gate status
            QUALITY_GATE=$(grep "QUALITY GATE STATUS:" {{.REPORT_PATH}}/sonar-scanner.log | head -1 || echo "")
            if [ -n "$QUALITY_GATE" ]; then
              echo "$QUALITY_GATE"
              echo ""
            fi

            # Extract issues from the log (these appear during analysis)
            echo "===================================================="
            echo "ISSUES FOUND DURING ANALYSIS"
            echo "===================================================="
            echo ""

            # Look for Swift file issues in the log
            grep -E "(ERROR|WARN|INFO).*Sources.*\\.swift" {{.REPORT_PATH}}/sonar-scanner.log | while read -r line; do
              echo "[CODE_SMELL] $line"
              echo "  Status: OPEN"
              echo ""
            done

            # If no issues found in log, create placeholder
            if ! grep -q -E "(ERROR|WARN|INFO).*Sources.*\\.swift" {{.REPORT_PATH}}/sonar-scanner.log; then
              echo "No issues found in scan log."
              echo "For detailed analysis results, view online at:"
              echo "https://sonarcloud.io/summary/overall?id=lekman_magsafe-buskill"
            fi

          } > {{.REPORT_PATH}}/sonarcloud-findings.txt

          echo "âœ… Findings extracted to {{.REPORT_PATH}}/sonarcloud-findings.txt"
        fi

        # Show any open issues as warnings
        if [ -f "{{.REPORT_PATH}}/sonarcloud-findings.txt" ]; then
          OPEN_ISSUES=$(grep -c "Status: OPEN\\|Status: CONFIRMED\\|Status: REOPENED" {{.REPORT_PATH}}/sonarcloud-findings.txt 2>/dev/null || echo 0)
          if [ $OPEN_ISSUES -gt 0 ]; then
            echo ""
            echo "âš ï¸  Found $OPEN_ISSUES open issues:"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            # Show first 5 open issues with their details
            awk '
              /^\\[CODE_SMELL\\]/ {
                issue = $0
                getline
                rule = $0
                getline
                msg = $0
                if (getline && /Status: (OPEN|CONFIRMED|REOPENED)/) {
                  count++
                  if (count <= 5) {
                    print issue
                    print "  " msg
                    print ""
                  }
                }
              }
            ' {{.REPORT_PATH}}/sonarcloud-findings.txt

            if [ $OPEN_ISSUES -gt 5 ]; then
              echo "... and $((OPEN_ISSUES - 5)) more open issues"
            fi
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          fi
        fi

        if [ $SCAN_RESULT -eq 0 ]; then
          echo ""
          echo "âœ… SonarCloud scan completed successfully"
          echo ""
          echo "Results saved to:"
          echo "  - Log: {{.REPORT_PATH}}/sonar-scanner.log"
          echo "  - Findings: {{.REPORT_PATH}}/sonarcloud-findings.txt"
          echo "  - View online: https://sonarcloud.io/summary/overall?id=lekman_magsafe-buskill"

          # Open the findings file in VSCode
          echo ""
          echo "ğŸ“‚ Opening findings report in VSCode..."
          code {{.REPORT_PATH}}/sonarcloud-findings.txt

          exit 0
        else
          echo ""
          echo "âŒ SonarCloud scan failed"
          echo "Check {{.REPORT_PATH}}/sonar-scanner.log for details"

          # Still try to open findings if they exist
          if [ -f "{{.REPORT_PATH}}/sonarcloud-findings.txt" ]; then
            code {{.REPORT_PATH}}/sonarcloud-findings.txt
          fi

          exit 1
        fi

  issues:
    desc: Display SonarCloud findings from previous scan
    silent: true
    vars:
      REPORT_PATH: "{{.PWD}}/.sonarcloud"
    cmds:
      - |
        echo "ğŸ“‹ Checking for SonarCloud findings..."

        FINDINGS_FILE="{{.REPORT_PATH}}/sonarcloud-findings.txt"
        LOG_FILE="{{.REPORT_PATH}}/sonar-scanner.log"

        # Check if findings file exists
        if [ -f "$FINDINGS_FILE" ]; then
          echo "âœ… Found findings report"
          echo ""

          # Show summary
          TOTAL_ISSUES=$(grep -c "^\\[CODE_SMELL\\]" "$FINDINGS_FILE" 2>/dev/null || echo 0)
          OPEN_ISSUES=$(grep -c "Status: OPEN\\|Status: CONFIRMED\\|Status: REOPENED" "$FINDINGS_FILE" 2>/dev/null || echo 0)
          CLOSED_ISSUES=$(grep -c "Status: CLOSED" "$FINDINGS_FILE" 2>/dev/null || echo 0)

          echo "ğŸ“Š Summary:"
          echo "  - Total issues: $TOTAL_ISSUES"
          echo "  - Open issues: $OPEN_ISSUES"
          echo "  - Closed issues: $CLOSED_ISSUES"
          echo ""

          # Show open issues
          if [ $OPEN_ISSUES -gt 0 ]; then
            echo "âš ï¸  Open Issues:"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            awk '
              /^\\[CODE_SMELL\\]/ {
                issue = $0
                getline
                rule = $0
                getline
                msg = $0
                if (getline && /Status: (OPEN|CONFIRMED|REOPENED)/) {
                  print issue
                  print "  " msg
                  print ""
                }
              }
            ' "$FINDINGS_FILE" | head -30
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          else
            echo "âœ… No open issues!"
          fi

          echo ""
          echo "ğŸ“‚ Opening full report in VSCode..."
          code "$FINDINGS_FILE"

        elif [ -f "$LOG_FILE" ]; then
          echo "âš ï¸  No findings report found, but scan log exists"
          echo ""
          echo "The scan may have been interrupted or failed to generate findings."
          echo "Try running: task sonar:download"
          echo ""
          echo "Log file: $LOG_FILE"
        else
          echo "âŒ No SonarCloud scan results found"
          echo ""
          echo "To generate findings:"
          echo "  1. Run a local scan: task sonar:scan"
          echo "  2. Or download from SonarCloud: task sonar:download"
          echo ""
          echo "Note: Local scan requires sonar-scanner to be installed"
          echo "      Download requires SONAR_TOKEN in your .env file"
        fi

  download:
    desc: Download all SonarCloud findings to a local file
    silent: true
    vars:
      REPORT_PATH: .sonarcloud
      PROJECT_KEY: lekman_magsafe-buskill
    cmds:
      - |
        echo "ğŸ“¥ Downloading SonarCloud findings..."

        # Source .env file if it exists
        if [ -f .env ]; then
          set -a
          source .env
          set +a
        fi

        # Check for SONAR_TOKEN
        if [ -z "$SONAR_TOKEN" ]; then
          echo "âŒ SONAR_TOKEN environment variable is not set"
          echo ""
          echo "To download SonarCloud findings, you need to:"
          echo "1. Get your token from: https://sonarcloud.io/account/security"
          echo "2. Add it to your .env file:"
          echo "   echo 'SONAR_TOKEN=your-token-here' >> .env"
          echo "3. Run this task again"
          exit 1
        fi

        # Create report directory
        mkdir -p {{.REPORT_PATH}}

        # Download issues from SonarCloud API
        echo "ğŸ” Fetching issues from SonarCloud..."

        # Fetch all issues (pagination handled)
        PAGE=1
        TOTAL_PAGES=1
        > {{.REPORT_PATH}}/sonarcloud-issues.json

        while [ $PAGE -le $TOTAL_PAGES ]; do
          echo "  Fetching page $PAGE..."

          RESPONSE=$(curl -s -X GET \
            "https://sonarcloud.io/api/issues/search?componentKeys={{.PROJECT_KEY}}&p=$PAGE&ps=500" \
            -H "Authorization: Bearer $SONAR_TOKEN")

          # Check if request was successful
          if [ $? -ne 0 ] || [ -z "$RESPONSE" ]; then
            echo "âŒ Failed to fetch issues from SonarCloud"
            exit 1
          fi

          # Extract total pages on first iteration
          if [ $PAGE -eq 1 ]; then
            TOTAL_PAGES=$(echo "$RESPONSE" | python3 -c "import json,sys,math; data=json.load(sys.stdin); print(math.ceil(data.get('paging',{}).get('total',0)/500))" 2>/dev/null || echo "1")
            echo "$RESPONSE" > {{.REPORT_PATH}}/sonarcloud-issues.json
          else
            # Append issues from subsequent pages
            echo "$RESPONSE" | python3 -c "import json,sys; data=json.load(sys.stdin); f=open('{{.REPORT_PATH}}/sonarcloud-issues.json','r+'); existing=json.load(f); existing['issues'].extend(data.get('issues',[])); f.seek(0); json.dump(existing,f,indent=2); f.truncate(); f.close()" 2>/dev/null || true
          fi

          PAGE=$((PAGE + 1))
        done

        # Generate human-readable report
        echo "ğŸ“ Generating readable report..."

        # Create temp Python script for processing
        cat > {{.REPORT_PATH}}/process_issues.py << 'SCRIPT_EOF'
        import json
        import sys
        from datetime import datetime

        report_path = '.sonarcloud'
        project_key = 'lekman_magsafe-buskill'

        try:
            with open(f'{report_path}/sonarcloud-issues.json', 'r') as f:
                data = json.load(f)

            issues = data.get('issues', [])

            # Generate report
            with open(f'{report_path}/sonarcloud-findings.txt', 'w') as report:
                report.write(f'=== SonarCloud Findings Report ===\
        ')
                report.write(f'Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}\
        ')
                report.write(f'Project: {project_key}\
        ')
                report.write(f'Total issues: {len(issues)}\
        \
        ')

                # Group by severity
                by_severity = {}
                for issue in issues:
                    severity = issue.get('severity', 'UNKNOWN')
                    if severity not in by_severity:
                        by_severity[severity] = []
                    by_severity[severity].append(issue)

                # Write issues by severity
                for severity in ['BLOCKER', 'CRITICAL', 'MAJOR', 'MINOR', 'INFO']:
                    if severity not in by_severity:
                        continue

                    report.write(f'\
        {"=" * 50}\
        ')
                    report.write(f'{severity} ISSUES ({len(by_severity[severity])})\
        ')
                    report.write(f'{"=" * 50}\
        \
        ')

                    for issue in by_severity[severity]:
                        component = issue.get('component', 'unknown').replace(f'{project_key}:', '')
                        line = issue.get('textRange', {}).get('startLine', 0)

                        report.write(f'[{issue.get("type", "UNKNOWN")}] {component}:{line}\
        ')
                        report.write(f'  Rule: {issue.get("rule", "unknown")}\
        ')
                        report.write(f'  Message: {issue.get("message", "No message")}\
        ')

                        # Add effort if available
                        effort = issue.get('effort')
                        if effort:
                            report.write(f'  Effort: {effort}\
        ')

                        # Add status
                        status = issue.get('status', 'OPEN')
                        if status != 'OPEN':
                            report.write(f'  Status: {status}\
        ')

                        report.write('\
        ')

            print(f'âœ… Successfully processed {len(issues)} issues')

        except Exception as e:
            print(f'Error processing SonarCloud response: {e}')
            sys.exit(1)
        SCRIPT_EOF

        python3 {{.REPORT_PATH}}/process_issues.py || exit 1
        rm -f {{.REPORT_PATH}}/process_issues.py

        echo ""
        echo "ğŸ“Š Summary:"

        # Create temp Python script for summary
        cat > {{.REPORT_PATH}}/summary.py << 'SCRIPT_EOF'
        import json
        import sys

        report_path = '.sonarcloud'

        with open(f'{report_path}/sonarcloud-issues.json', 'r') as f:
            data = json.load(f)
            issues = data.get('issues', [])

            # Count by type
            types = {}
            severities = {}
            for issue in issues:
                issue_type = issue.get('type', 'UNKNOWN')
                severity = issue.get('severity', 'UNKNOWN')
                types[issue_type] = types.get(issue_type, 0) + 1
                severities[severity] = severities.get(severity, 0) + 1

            print('By Type:')
            for t, count in sorted(types.items()):
                print(f'  - {t}: {count}')

            print('\
        By Severity:')
            for s in ['BLOCKER', 'CRITICAL', 'MAJOR', 'MINOR', 'INFO']:
                if s in severities:
                    print(f'  - {s}: {severities[s]}')
        SCRIPT_EOF

        python3 {{.REPORT_PATH}}/summary.py
        rm -f {{.REPORT_PATH}}/summary.py

        echo ""
        echo "âœ… Download completed"
        echo ""
        echo "Results saved to:"
        echo "  - Full JSON: {{.REPORT_PATH}}/sonarcloud-issues.json"
        echo "  - Readable report: {{.REPORT_PATH}}/sonarcloud-findings.txt"
        echo ""
        echo "To view the report: cat {{.REPORT_PATH}}/sonarcloud-findings.txt | less"

  download:pr:
    desc: Download SonarCloud pull request report (use PR=123 to specify PR number)
    silent: true
    vars:
      REPORT_PATH: .sonarcloud
      PROJECT_KEY: lekman_magsafe-buskill
      ORGANIZATION: lekman
      SONAR_API_BASE: https://sonarcloud.io/api
    cmds:
      - |
        echo "ğŸ“¥ Downloading SonarCloud pull request report..."

        # Show usage if help is requested
        if [ "${PR}" = "help" ] || [ "${PR}" = "--help" ]; then
          echo ""
          echo "Usage:"
          echo "  task sonar:download:pr         # Interactive mode - choose from list"
          echo "  PR=123 task sonar:download:pr  # Download specific PR"
          echo "  PR=latest task sonar:download:pr  # Download latest PR (non-interactive)"
          echo ""
          exit 0
        fi

        # Source .env file if it exists
        if [ -f .env ]; then
          set -a
          source .env
          set +a
        fi

        # Check for SONAR_TOKEN
        if [ -z "$SONAR_TOKEN" ]; then
          echo "âŒ SONAR_TOKEN environment variable is not set"
          echo ""
          echo "To download SonarCloud findings, you need to:"
          echo "1. Get your token from: https://sonarcloud.io/account/security"
          echo "2. Add it to your .env file:"
          echo "   echo 'SONAR_TOKEN=your-token-here' >> .env"
          echo "3. Run this task again"
          exit 1
        fi

        # Get current branch for reference
        CURRENT_BRANCH=$(git branch --show-current)

        # Get PR number from CLI args or try to detect
        PR_NUMBER="${PR:-}"
        PR_TITLE=""
        PR_BRANCH=""

        # First, list all pull requests
        echo "ğŸ“‹ Fetching pull requests from SonarCloud..."
        PR_LIST=$(curl -s -X GET \
          "{{.SONAR_API_BASE}}/project_pull_requests/list?project={{.PROJECT_KEY}}" \
          -H "Authorization: Bearer $SONAR_TOKEN")

        if [ $? -ne 0 ] || [ -z "$PR_LIST" ]; then
          echo "âŒ Failed to fetch pull request list"
          exit 1
        fi

        # Handle "latest" keyword
        if [ "$PR_NUMBER" = "latest" ]; then
          PR_NUMBER=$(echo "$PR_LIST" | jq -r '.pullRequests[0].key' 2>/dev/null || echo "")
          if [ -n "$PR_NUMBER" ]; then
            echo "ğŸ“Œ Using latest PR: #$PR_NUMBER"
          else
            echo "âŒ No pull requests found"
            exit 1
          fi
        elif [ -z "$PR_NUMBER" ]; then
          echo "ğŸ” Current git branch: $CURRENT_BRANCH"

          # Display available PRs
          echo ""
          echo "Available pull requests:"
          echo "$PR_LIST" | jq -r '.pullRequests[] | "  PR #\\(.key): \\(.title) [\\(.status)]"' 2>/dev/null || echo "  Unable to parse PR list"

          echo ""
          echo "Enter PR number, 'latest' for most recent, or press Enter to choose latest:"
          read -p "PR selection: " PR_NUMBER

          # If still empty or "latest", get the latest PR
          if [ -z "$PR_NUMBER" ] || [ "$PR_NUMBER" = "latest" ]; then
            PR_NUMBER=$(echo "$PR_LIST" | jq -r '.pullRequests[0].key' 2>/dev/null || echo "")
            if [ -n "$PR_NUMBER" ]; then
              echo "ğŸ“Œ Using latest PR: #$PR_NUMBER"
            else
              echo "âŒ No pull requests found"
              exit 1
            fi
          fi
        else
          echo "ğŸ“Œ Using specified PR: #$PR_NUMBER"
        fi

        # Extract PR details
        PR_DATA=$(echo "$PR_LIST" | jq -r ".pullRequests[] | select(.key == \"$PR_NUMBER\")" 2>/dev/null)
        if [ -n "$PR_DATA" ]; then
          PR_TITLE=$(echo "$PR_DATA" | jq -r '.title' 2>/dev/null || echo "")
          PR_BRANCH=$(echo "$PR_DATA" | jq -r '.branch' 2>/dev/null || echo "")
        fi

        # Create report directory
        mkdir -p {{.REPORT_PATH}}

        echo "ğŸ” Fetching PR #$PR_NUMBER analysis..."

        # Function to make API calls
        api_call() {
          local endpoint="$1"
          curl -s -H "Authorization: Bearer $SONAR_TOKEN" "{{.SONAR_API_BASE}}/$endpoint"
        }

        # Get PR issues
        echo "ğŸ“‹ Fetching PR issues..."
        ISSUES_DATA=$(api_call "issues/search?pullRequest=$PR_NUMBER&componentKeys={{.PROJECT_KEY}}&resolved=false")
        echo "$ISSUES_DATA" > "{{.REPORT_PATH}}/pr-$PR_NUMBER-issues.json"

        # Get PR measures
        echo "ğŸ“Š Fetching PR measures..."
        MEASURES_DATA=$(api_call "measures/component?component={{.PROJECT_KEY}}&pullRequest=$PR_NUMBER&metricKeys=bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density")
        echo "$MEASURES_DATA" > "{{.REPORT_PATH}}/pr-$PR_NUMBER-measures.json"

        # Process to Markdown
        echo "ğŸ“ Generating markdown report..."

        # Extract data for report
        TOTAL_ISSUES=$(echo "$ISSUES_DATA" | jq -r '.total' 2>/dev/null || echo "0")
        BUGS=$(echo "$MEASURES_DATA" | jq -r '.component.measures[] | select(.metric == "bugs") | .value' 2>/dev/null || echo "N/A")
        VULNERABILITIES=$(echo "$MEASURES_DATA" | jq -r '.component.measures[] | select(.metric == "vulnerabilities") | .value' 2>/dev/null || echo "N/A")
        CODE_SMELLS=$(echo "$MEASURES_DATA" | jq -r '.component.measures[] | select(.metric == "code_smells") | .value' 2>/dev/null || echo "N/A")
        COVERAGE=$(echo "$MEASURES_DATA" | jq -r '.component.measures[] | select(.metric == "coverage") | .value' 2>/dev/null || echo "N/A")
        DUPLICATION=$(echo "$MEASURES_DATA" | jq -r '.component.measures[] | select(.metric == "duplicated_lines_density") | .value' 2>/dev/null || echo "N/A")

        # Create markdown report using echo to avoid YAML parsing issues
        {
          echo "# SonarCloud Analysis Report"
          echo ""
          echo "**Project:** {{.PROJECT_KEY}}  "
          echo "**Organization:** {{.ORGANIZATION}}  "
          echo "**Pull Request:** #$PR_NUMBER${PR_TITLE:+ - $PR_TITLE}  "
          echo "**Branch:** ${PR_BRANCH:-Unknown}  "
          echo "**Current Git Branch:** $CURRENT_BRANCH  "
          echo "**Generated:** $(date)  "
          echo ""
          echo "## Quality Metrics"
          echo ""
          echo "| Metric | Value |"
          echo "|--------|-------|"
          echo "| ğŸ› Bugs | $BUGS |"
          echo "| ğŸ”’ Vulnerabilities | $VULNERABILITIES |"
          echo "| ğŸŒ«ï¸ Code Smells | $CODE_SMELLS |"
          echo "| ğŸ“Š Coverage | ${COVERAGE}% |"
          echo "| ğŸ“‹ Duplication | ${DUPLICATION}% |"
          echo ""
          echo "## Issues ($TOTAL_ISSUES)"
          echo ""
        } > "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"

        if [[ "$TOTAL_ISSUES" -gt 0 ]]; then
          echo "### By Severity" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
          echo "" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"

          for severity in BLOCKER CRITICAL MAJOR MINOR INFO; do
            COUNT=$(echo "$ISSUES_DATA" | jq -r ".issues[] | select(.severity == \"$severity\") | .key" 2>/dev/null | wc -l | tr -d ' ')
            if [[ "$COUNT" -gt 0 ]]; then
              echo "- **$severity**: $COUNT issues" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
            fi
          done

          echo "" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
          echo "### Issue Details" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
          echo "" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"

          # List issues (limit to first 50)
          echo "$ISSUES_DATA" | jq -r '.issues[] | "- **\(.severity)** [\(.rule)](https://rules.sonarsource.com/swift/RSPEC-\(.rule | split(":")[1])): \(.message) (`\(.component | split(":")[1]):\(.line)`)"' 2>/dev/null | head -50 >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md" || true

          REMAINING=$((TOTAL_ISSUES - 50))
          if [[ $REMAINING -gt 0 ]]; then
            echo "" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
            echo "*... and $REMAINING more issues*" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
          fi
        else
          echo "*No issues found! ğŸ‰*" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
        fi

        echo "" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
        echo "---" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
        echo "[View full report on SonarCloud](https://sonarcloud.io/pullrequests/overview?id={{.PROJECT_KEY}}&pullRequest=$PR_NUMBER)" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"

        echo ""
        echo "âœ… PR report downloaded"
        echo ""
        echo "Results saved to:"
        echo "  - Markdown report: {{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
        echo "  - Issues JSON: {{.REPORT_PATH}}/pr-$PR_NUMBER-issues.json"
        echo "  - Measures JSON: {{.REPORT_PATH}}/pr-$PR_NUMBER-measures.json"
        echo ""
        echo "ğŸ“‚ Opening report in VSCode..."
        code "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"

  convert:
    desc: Convert Swift coverage to SonarQube generic XML format
    silent: true
    cmds:
      - |
        echo "ğŸ”„ Converting Swift coverage to SonarQube format..."

        # Check if coverage.xml already exists
        if [ -f "coverage.xml" ]; then
          echo "âœ… coverage.xml already exists - no conversion needed"
          exit 0
        fi

        # Check if we have coverage data from SPM tests
        if [ ! -f "coverage.lcov" ]; then
          echo "âŒ No coverage.lcov file found"
          echo "   Run 'task swift:test' first to generate coverage data"
          exit 1
        fi

        # Use Python to convert LCOV to Cobertura XML
        echo "ğŸ“Š Converting LCOV to Cobertura XML..."
        
        python3 -c '
import sys
import re
from xml.etree.ElementTree import Element, SubElement, tostring
from xml.dom import minidom

def parse_lcov(lcov_path):
    """Parse LCOV file and return coverage data."""
    coverage_data = {}
    current_file = None
    
    with open(lcov_path, "r") as f:
        for line in f:
            line = line.strip()
            if line.startswith("SF:"):
                current_file = line[3:]
                coverage_data[current_file] = {"lines": {}, "found": 0, "hit": 0}
            elif line.startswith("DA:") and current_file:
                parts = line[3:].split(",")
                if len(parts) == 2:
                    line_num = int(parts[0])
                    hit_count = int(parts[1])
                    coverage_data[current_file]["lines"][line_num] = hit_count
                    coverage_data[current_file]["found"] += 1
                    if hit_count > 0:
                        coverage_data[current_file]["hit"] += 1
            elif line.startswith("end_of_record"):
                current_file = None
    
    return coverage_data

def create_cobertura_xml(coverage_data):
    """Convert coverage data to Cobertura XML format."""
    coverage = Element("coverage")
    coverage.set("version", "1")
    coverage.set("line-rate", "0")
    coverage.set("branch-rate", "0")
    
    packages = SubElement(coverage, "packages")
    package = SubElement(packages, "package")
    package.set("name", "MagSafeGuard")
    package.set("line-rate", "0")
    package.set("branch-rate", "0")
    
    classes = SubElement(package, "classes")
    
    total_lines = 0
    total_hits = 0
    
    for filepath, data in coverage_data.items():
        # Skip test files
        if "Tests" in filepath or "Mock" in filepath:
            continue
            
        class_elem = SubElement(classes, "class")
        class_elem.set("name", filepath.split("/")[-1].replace(".swift", ""))
        class_elem.set("filename", filepath)
        
        lines = SubElement(class_elem, "lines")
        
        for line_num, hit_count in sorted(data["lines"].items()):
            line = SubElement(lines, "line")
            line.set("number", str(line_num))
            line.set("hits", str(hit_count))
            
        total_lines += data["found"]
        total_hits += data["hit"]
        
        if data["found"] > 0:
            class_elem.set("line-rate", str(data["hit"] / data["found"]))
        else:
            class_elem.set("line-rate", "0")
        class_elem.set("branch-rate", "0")
    
    # Update overall rates
    if total_lines > 0:
        line_rate = total_hits / total_lines
        coverage.set("line-rate", str(line_rate))
        package.set("line-rate", str(line_rate))
    
    # Pretty print
    rough_string = tostring(coverage, encoding="unicode")
    reparsed = minidom.parseString(rough_string)
    return reparsed.toprettyxml(indent="  ")

# Main conversion
try:
    coverage_data = parse_lcov("coverage.lcov")
    xml_output = create_cobertura_xml(coverage_data)
    with open("coverage.xml", "w") as f:
        f.write(xml_output)
    print("âœ… Successfully converted LCOV to Cobertura XML")
except Exception as e:
    print(f"âŒ Conversion failed: {e}")
    sys.exit(1)
' || {
          echo "âŒ Python conversion failed, creating minimal XML"
          # Fallback: Create minimal valid XML
          echo '<?xml version="1.0" ?>' > coverage.xml
          echo '<coverage version="1">' >> coverage.xml
          echo '  <packages/>' >> coverage.xml  
          echo '</coverage>' >> coverage.xml
        }

        if [ -f "coverage.xml" ] && [ -s "coverage.xml" ]; then
          echo "   File size: $(wc -c < coverage.xml) bytes"
          # Count files in coverage.xml if it has valid structure
          if grep -q '<class' coverage.xml 2>/dev/null; then
            echo "   Files covered: $(grep -c '<class' coverage.xml || echo 0)"
          fi
        else
          echo "âŒ Failed to create coverage.xml or file is empty"
          exit 1
        fi

  setup:
    desc: Setup SonarCloud scanner
    silent: true
    cmds:
      - |
        echo "ğŸ”§ Setting up SonarCloud scanner..."

        # Check if already installed
        if command -v sonar-scanner &> /dev/null; then
          echo "âœ… sonar-scanner already installed ($(sonar-scanner -v | grep -oE '[0-9]+\\.[0-9]+\\.[0-9]+' | head -1))"

          # Check for updates on macOS
          if command -v brew &> /dev/null && brew list sonar-scanner &>/dev/null; then
            if brew outdated | grep -q "^sonar-scanner"; then
              echo "ğŸ“¦ Updating sonar-scanner..."
              brew upgrade sonar-scanner
            fi
          fi
          exit 0
        fi

        # Detect OS for fresh installation
        OS=$(uname -s | tr '[:upper:]' '[:lower:]')

        if [ "$OS" = "darwin" ]; then
          # macOS
          if command -v brew &> /dev/null; then
            echo "ğŸ“¦ Installing via Homebrew..."
            brew install sonar-scanner
          else
            echo "âŒ Homebrew not found. Please install Homebrew first:"
            echo "   /bin/bash -c \\"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\\""
            exit 1
          fi
        elif [ "$OS" = "linux" ]; then
          # Linux
          echo "ğŸ“¦ Installing SonarCloud scanner for Linux..."

          # Check if running in CI or local
          if [ -n "$CI" ] || [ ! -w "/usr/local" ]; then
            # Download to local directory
            INSTALL_DIR="$HOME/.local/bin"
            mkdir -p "$INSTALL_DIR"

            echo "â¬‡ï¸  Downloading sonar-scanner..."
            curl -sSL https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-4.8.0.2856-linux.zip -o /tmp/sonar-scanner.zip

            echo "ğŸ“‚ Extracting..."
            unzip -q /tmp/sonar-scanner.zip -d /tmp/
            mv /tmp/sonar-scanner-*/* "$INSTALL_DIR/"
            rm -rf /tmp/sonar-scanner*

            echo "âœ… Installed to $INSTALL_DIR"
            echo "âš ï¸  Make sure $INSTALL_DIR is in your PATH"
          else
            # System-wide install
            echo "â¬‡ï¸  Downloading sonar-scanner..."
            curl -sSL https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-4.8.0.2856-linux.zip -o /tmp/sonar-scanner.zip

            echo "ğŸ“‚ Extracting..."
            sudo unzip -q /tmp/sonar-scanner.zip -d /opt/
            sudo ln -sf /opt/sonar-scanner-*/bin/sonar-scanner /usr/local/bin/sonar-scanner
            rm /tmp/sonar-scanner.zip

            echo "âœ… Installed system-wide"
          fi
        else
          echo "âŒ Unsupported OS: $OS"
          echo "Please install manually from:"
          echo "https://docs.sonarcloud.io/advanced-setup/ci-based-analysis/sonarscanner-cli/"
          exit 1
        fi

        # Verify installation
        if command -v sonar-scanner &> /dev/null; then
          echo ""
          echo "âœ… SonarCloud scanner installed successfully!"
          sonar-scanner -v
        else
          echo "âš ï¸  Installation completed but sonar-scanner not found in PATH"
          echo "You may need to restart your terminal or add the installation directory to PATH"
        fi
