# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: "3"
# SonarCloud Tasks
# This file is self-contained and can be reused in other projects.
# All scripts are embedded inline for maximum portability.
#
# Configuration:
# - Set PROJECT_KEY and ORGANIZATION vars for your project
# - Add SONAR_TOKEN to your .env file
# - Adjust exclusion patterns as needed
tasks:
  default:
    desc: List available SonarCloud tasks
    silent: true
    cmds:
      - task --list | grep "^\\* sonar:" | grep -v "::" || true
  scan:
    desc: Run SonarCloud scan locally
    silent: true
    vars:
      REPORT_PATH: "{{.PWD}}/.sonarcloud"
    cmds:
      - |
        #!/bin/bash
        echo "\U0001F50D Running SonarCloud scan locally..."

        # Source .env file if it exists
        if [ -f .env ]; then
          echo "\U0001F4C4 Loading environment variables from .env"
          set -a
          source .env
          set +a
        fi

        # Check if sonar-scanner is installed
        if ! command -v sonar-scanner &> /dev/null; then
          echo "❌ sonar-scanner is not installed"
          echo ""
          echo "To install on macOS:"
          echo "  brew install sonar-scanner"
          echo ""
          echo "To install on Linux:"
          echo "  Download from https://docs.sonarcloud.io/advanced-setup/ci-based-analysis/sonarscanner-cli/"
          echo ""
          echo "Alternative: Use 'task sonar:simulate' to simulate issues based on SwiftLint"
          echo ""
          exit 1
        fi

        # Check for SONAR_TOKEN
        if [ -z "$SONAR_TOKEN" ]; then
          echo "❌ SONAR_TOKEN environment variable is not set"
          echo ""
          echo "To run SonarCloud analysis, you need to:"
          echo "1. Get your token from: https://sonarcloud.io/account/security"
          echo "2. Add it to your .env file:"
          echo "   echo 'SONAR_TOKEN=your-token-here' >> .env"
          echo "3. Run this task again"
          echo ""
          echo "Alternative: Use 'task sonar:simulate' for local analysis without SonarCloud"
          exit 1
        fi

        # Create report directory
        mkdir -p {{.REPORT_PATH}}

        # Check if coverage.xml already exists
        if [ -f "coverage.xml" ]; then
          echo "✅ Found existing coverage.xml - skipping test and conversion steps"
          COVERAGE_SIZE=$(wc -c < coverage.xml)
          COVERAGE_FILES=$(grep -c '<file path=' coverage.xml || echo 0)
          echo "   File size: ${COVERAGE_SIZE} bytes"
          echo "   Files covered: ${COVERAGE_FILES}"
        else
          # Run tests with coverage first
          echo "\U0001F4CA Generating coverage data..."
          task swift:test:coverage

          # Convert coverage to SonarQube format
          echo "\U0001F504 Converting coverage to SonarQube format..."
          task sonar:convert

          # Check if coverage files exist after generation
          if [ ! -f "coverage.xml" ]; then
            echo "⚠️  No coverage.xml found. Running scan without coverage data."
          fi
        fi

        # Run sonar-scanner with performance optimizations
        echo "\U0001F680 Running SonarCloud analysis..."
        echo "\U0001F4CA Scanning only Swift source files in Sources/ and Tests/"

        # Full analysis with upload to SonarCloud and performance optimizations
        sonar-scanner \\
          -Dsonar.host.url=https://sonarcloud.io \\
          -Dsonar.token=$SONAR_TOKEN \\
          -Dsonar.scanner.metadataFilePath={{.REPORT_PATH}}/report-task.txt \\
          -Dsonar.working.directory={{.REPORT_PATH}}/.scannerwork \\
          2>&1 | tee {{.REPORT_PATH}}/sonar-scanner.log

        # Check result (capture exit code before it's lost)
        SCAN_RESULT=$?

        # Extract issues from the scan log to create findings file
        echo ""
        echo "\U0001F4CB Extracting findings from scan log..."

        # Create findings file from the scanner log
        if [ -f "{{.REPORT_PATH}}/sonar-scanner.log" ]; then
          {
            echo "=== SonarCloud Findings Report ==="
            echo "Generated: $(date)"
            echo "Project: lekman_magsafe-buskill"
            echo ""
            
            # Extract quality gate status
            QUALITY_GATE=$(grep "QUALITY GATE STATUS:" {{.REPORT_PATH}}/sonar-scanner.log | head -1 || echo "")
            if [ -n "$QUALITY_GATE" ]; then
              echo "$QUALITY_GATE"
              echo ""
            fi
            
            # Extract issues from the log (these appear during analysis)
            echo "===================================================="
            echo "ISSUES FOUND DURING ANALYSIS"
            echo "===================================================="
            echo ""
            
            # Look for Swift file issues in the log
            grep -E "(ERROR|WARN|INFO).*Sources.*\\.swift" {{.REPORT_PATH}}/sonar-scanner.log | while read -r line; do
              echo "[CODE_SMELL] $line"
              echo "  Status: OPEN"
              echo ""
            done
            
            # If no issues found in log, create placeholder
            if ! grep -q -E "(ERROR|WARN|INFO).*Sources.*\\.swift" {{.REPORT_PATH}}/sonar-scanner.log; then
              echo "No issues found in scan log."
              echo "For detailed analysis results, view online at:"
              echo "https://sonarcloud.io/summary/overall?id=lekman_magsafe-buskill"
            fi
            
          } > {{.REPORT_PATH}}/sonarcloud-findings.txt
          
          echo "✅ Findings extracted to {{.REPORT_PATH}}/sonarcloud-findings.txt"
        fi

        # Show any open issues as warnings
        if [ -f "{{.REPORT_PATH}}/sonarcloud-findings.txt" ]; then
          OPEN_ISSUES=$(grep -c "Status: OPEN\\|Status: CONFIRMED\\|Status: REOPENED" {{.REPORT_PATH}}/sonarcloud-findings.txt 2>/dev/null || echo 0)
          if [ $OPEN_ISSUES -gt 0 ]; then
            echo ""
            echo "⚠️  Found $OPEN_ISSUES open issues:"
            echo "─────────────────────────────"
            # Show first 5 open issues with their details
            awk '
              /^\\[CODE_SMELL\\]/ { 
                issue = $0
                getline
                rule = $0
                getline
                msg = $0
                if (getline && /Status: (OPEN|CONFIRMED|REOPENED)/) {
                  count++
                  if (count <= 5) {
                    print issue
                    print "  " msg
                    print ""
                  }
                }
              }
            ' {{.REPORT_PATH}}/sonarcloud-findings.txt
            
            if [ $OPEN_ISSUES -gt 5 ]; then
              echo "... and $((OPEN_ISSUES - 5)) more open issues"
            fi
            echo "─────────────────────────────"
          fi
        fi

        if [ $SCAN_RESULT -eq 0 ]; then
          echo ""
          echo "✅ SonarCloud scan completed successfully"
          echo ""
          echo "Results saved to:"
          echo "  - Log: {{.REPORT_PATH}}/sonar-scanner.log"
          echo "  - Findings: {{.REPORT_PATH}}/sonarcloud-findings.txt"
          echo "  - View online: https://sonarcloud.io/summary/overall?id=lekman_magsafe-buskill"
          
          # Open the findings file in VSCode
          echo ""
          echo "\U0001F4C2 Opening findings report in VSCode..."
          code {{.REPORT_PATH}}/sonarcloud-findings.txt
          
          exit 0
        else
          echo ""
          echo "❌ SonarCloud scan failed"
          echo "Check {{.REPORT_PATH}}/sonar-scanner.log for details"
          
          # Still try to open findings if they exist
          if [ -f "{{.REPORT_PATH}}/sonarcloud-findings.txt" ]; then
            code {{.REPORT_PATH}}/sonarcloud-findings.txt
          fi
          
          exit 1
        fi

  issues:
    desc: Display SonarCloud findings from previous scan
    silent: true
    vars:
      REPORT_PATH: "{{.PWD}}/.sonarcloud"
    cmds:
      - |
        echo "\U0001F4CB Checking for SonarCloud findings..."

        FINDINGS_FILE="{{.REPORT_PATH}}/sonarcloud-findings.txt"
        LOG_FILE="{{.REPORT_PATH}}/sonar-scanner.log"

        # Check if findings file exists
        if [ -f "$FINDINGS_FILE" ]; then
          echo "✅ Found findings report"
          echo ""
          
          # Show summary
          TOTAL_ISSUES=$(grep -c "^\\[CODE_SMELL\\]" "$FINDINGS_FILE" 2>/dev/null || echo 0)
          OPEN_ISSUES=$(grep -c "Status: OPEN\\|Status: CONFIRMED\\|Status: REOPENED" "$FINDINGS_FILE" 2>/dev/null || echo 0)
          CLOSED_ISSUES=$(grep -c "Status: CLOSED" "$FINDINGS_FILE" 2>/dev/null || echo 0)
          
          echo "\U0001F4CA Summary:"
          echo "  - Total issues: $TOTAL_ISSUES"
          echo "  - Open issues: $OPEN_ISSUES"
          echo "  - Closed issues: $CLOSED_ISSUES"
          echo ""
          
          # Show open issues
          if [ $OPEN_ISSUES -gt 0 ]; then
            echo "⚠️  Open Issues:"
            echo "─────────────────────────────"
            awk '
              /^\\[CODE_SMELL\\]/ { 
                issue = $0
                getline
                rule = $0
                getline
                msg = $0
                if (getline && /Status: (OPEN|CONFIRMED|REOPENED)/) {
                  print issue
                  print "  " msg
                  print ""
                }
              }
            ' "$FINDINGS_FILE" | head -30
            echo "─────────────────────────────"
          else
            echo "✅ No open issues!"
          fi
          
          echo ""
          echo "\U0001F4C2 Opening full report in VSCode..."
          code "$FINDINGS_FILE"
          
        elif [ -f "$LOG_FILE" ]; then
          echo "⚠️  No findings report found, but scan log exists"
          echo ""
          echo "The scan may have been interrupted or failed to generate findings."
          echo "Try running: task sonar:download"
          echo ""
          echo "Log file: $LOG_FILE"
        else
          echo "❌ No SonarCloud scan results found"
          echo ""
          echo "To generate findings:"
          echo "  1. Run a local scan: task sonar:scan"
          echo "  2. Or download from SonarCloud: task sonar:download"
          echo ""
          echo "Note: Local scan requires sonar-scanner to be installed"
          echo "      Download requires SONAR_TOKEN in your .env file"
        fi

  simulate:
    desc: Simulate SonarCloud analysis using SwiftLint (when sonar-scanner is not available)
    silent: true
    vars:
      REPORT_PATH: .sonarcloud
    cmds:
      - |
        #!/bin/bash
        echo "\U0001F50D Simulating SonarCloud analysis using SwiftLint..."

        # Create report directory
        mkdir -p {{.REPORT_PATH}}

        # Run tests with coverage first
        echo "\U0001F4CA Generating coverage data..."
        task swift:test:coverage || true

        # Run SwiftLint and format as SonarCloud-like issues
        echo "\U0001F680 Running SwiftLint analysis..."

        # First run SwiftLint to get JSON output
        swiftlint lint --reporter json > {{.REPORT_PATH}}/swiftlint-output.json 2>/dev/null || true

        # Create a formatted report
        echo "=== SonarCloud Simulation Report ===" > {{.REPORT_PATH}}/simulation-report.txt
        echo "Generated: $(date)" >> {{.REPORT_PATH}}/simulation-report.txt
        echo "" >> {{.REPORT_PATH}}/simulation-report.txt
        echo "\U0001F4CA Coverage Summary:" >> {{.REPORT_PATH}}/simulation-report.txt

        # Add coverage info
        if [ -f "coverage-report.txt" ]; then
          tail -n 20 coverage-report.txt | grep -E "(Total coverage:|Files with low coverage:)" -A 10 >> {{.REPORT_PATH}}/simulation-report.txt || true
        else
          echo "No coverage data available" >> {{.REPORT_PATH}}/simulation-report.txt
        fi

        echo "" >> {{.REPORT_PATH}}/simulation-report.txt
        echo "\U0001F41B Code Issues (from SwiftLint):" >> {{.REPORT_PATH}}/simulation-report.txt
        echo "" >> {{.REPORT_PATH}}/simulation-report.txt

        # Process SwiftLint JSON inline - Create a temp Python script
        cat > {{.REPORT_PATH}}/process_swiftlint.py << 'SCRIPT_EOF'
        import json
        import sys

        try:
            with open('.sonarcloud/swiftlint-output.json', 'r') as f:
                issues = json.load(f)
            
            if not issues:
                print('No issues found')
                sys.exit(0)
            
            # Limit to first 50 issues
            for i, issue in enumerate(issues[:50]):
                severity = issue.get('severity', 'Warning')
                rule_id = issue.get('rule_id', 'unknown')
                
                # Categorize issue
                if severity == 'Error':
                    category = 'BUG'
                    level = 'BLOCKER'
                elif 'security' in rule_id.lower() or 'auth' in rule_id.lower():
                    category = 'SECURITY_HOTSPOT'
                    level = 'CRITICAL'
                else:
                    category = 'CODE_SMELL'
                    level = 'MINOR'
                
                # Format output
                file_path = issue.get('file', 'unknown')
                line = issue.get('line', 0)
                reason = issue.get('reason', 'No description')
                
                print(f'[{category}] {level}: {file_path}:{line}')
                print(f'  Message: {reason}')
                print(f'  Rule: {rule_id}')
                print()
            
            if len(issues) > 50:
                print(f'\
        ... and {len(issues) - 50} more issues')
                
        except Exception as e:
            print(f'Error processing SwiftLint output: {e}')
        SCRIPT_EOF

        python3 {{.REPORT_PATH}}/process_swiftlint.py >> {{.REPORT_PATH}}/simulation-report.txt
        rm -f {{.REPORT_PATH}}/process_swiftlint.py

        # Add metrics summary
        echo "" >> {{.REPORT_PATH}}/simulation-report.txt
        echo "\U0001F4C8 Quality Metrics:" >> {{.REPORT_PATH}}/simulation-report.txt
        echo "- Technical Debt: Estimated based on issue count" >> {{.REPORT_PATH}}/simulation-report.txt
        echo "- Maintainability Rating: Based on code smells" >> {{.REPORT_PATH}}/simulation-report.txt
        echo "- Reliability Rating: Based on bugs" >> {{.REPORT_PATH}}/simulation-report.txt
        echo "- Security Rating: Based on vulnerabilities" >> {{.REPORT_PATH}}/simulation-report.txt

        # Count issues and display summary
        ISSUE_COUNT=$(cat {{.REPORT_PATH}}/swiftlint-output.json | python3 -c "import json,sys; print(len(json.load(sys.stdin)))" 2>/dev/null || echo "0")

        echo ""
        echo "Total issues found: $ISSUE_COUNT"

        echo ""
        echo "✅ Simulation completed"
        echo ""
        echo "Results saved to:"
        echo "  - Report: {{.REPORT_PATH}}/simulation-report.txt"
        echo "  - SwiftLint JSON: {{.REPORT_PATH}}/swiftlint-output.json"
        echo ""
        echo "Note: This is a simulation using SwiftLint. For full SonarCloud analysis:"
        echo "  1. Install sonar-scanner: brew install sonar-scanner"
        echo "  2. Run: task sonar:scan"

  view:
    desc: View the most recent SonarCloud simulation report
    silent: true
    cmds:
      - |
        if [ -f ".sonarcloud/simulation-report.txt" ]; then
          echo "\U0001F4CB Viewing SonarCloud simulation report..."
          echo ""
          cat .sonarcloud/simulation-report.txt | head -100
          echo ""
          echo "---"
          echo "Note: Showing first 100 lines. Full report: .sonarcloud/simulation-report.txt"
        else
          echo "❌ No simulation report found."
          echo "Run 'task sonar:simulate' first to generate a report."
        fi
  download:
    desc: Download all SonarCloud findings to a local file
    silent: true
    vars:
      REPORT_PATH: .sonarcloud
      PROJECT_KEY: lekman_magsafe-buskill
    cmds:
      - |
        echo "\U0001F4E5 Downloading SonarCloud findings..."

        # Source .env file if it exists
        if [ -f .env ]; then
          set -a
          source .env
          set +a
        fi

        # Check for SONAR_TOKEN
        if [ -z "$SONAR_TOKEN" ]; then
          echo "❌ SONAR_TOKEN environment variable is not set"
          echo ""
          echo "To download SonarCloud findings, you need to:"
          echo "1. Get your token from: https://sonarcloud.io/account/security"
          echo "2. Add it to your .env file:"
          echo "   echo 'SONAR_TOKEN=your-token-here' >> .env"
          echo "3. Run this task again"
          exit 1
        fi

        # Create report directory
        mkdir -p {{.REPORT_PATH}}

        # Download issues from SonarCloud API
        echo "\U0001F50D Fetching issues from SonarCloud..."

        # Fetch all issues (pagination handled)
        PAGE=1
        TOTAL_PAGES=1
        > {{.REPORT_PATH}}/sonarcloud-issues.json

        while [ $PAGE -le $TOTAL_PAGES ]; do
          echo "  Fetching page $PAGE..."
          
          RESPONSE=$(curl -s -X GET \\
            "https://sonarcloud.io/api/issues/search?componentKeys={{.PROJECT_KEY}}&p=$PAGE&ps=500" \\
            -H "Authorization: Bearer $SONAR_TOKEN")
          
          # Check if request was successful
          if [ $? -ne 0 ] || [ -z "$RESPONSE" ]; then
            echo "❌ Failed to fetch issues from SonarCloud"
            exit 1
          fi
          
          # Extract total pages on first iteration
          if [ $PAGE -eq 1 ]; then
            TOTAL_PAGES=$(echo "$RESPONSE" | python3 -c "import json,sys,math; data=json.load(sys.stdin); print(math.ceil(data.get('paging',{}).get('total',0)/500))" 2>/dev/null || echo "1")
            echo "$RESPONSE" > {{.REPORT_PATH}}/sonarcloud-issues.json
          else
            # Append issues from subsequent pages
            echo "$RESPONSE" | python3 -c "import json,sys; data=json.load(sys.stdin); f=open('{{.REPORT_PATH}}/sonarcloud-issues.json','r+'); existing=json.load(f); existing['issues'].extend(data.get('issues',[])); f.seek(0); json.dump(existing,f,indent=2); f.truncate(); f.close()" 2>/dev/null || true
          fi
          
          PAGE=$((PAGE + 1))
        done

        # Generate human-readable report
        echo "\U0001F4DD Generating readable report..."

        # Create temp Python script for processing
        cat > {{.REPORT_PATH}}/process_issues.py << 'SCRIPT_EOF'
        import json
        import sys
        from datetime import datetime

        report_path = '.sonarcloud'
        project_key = 'lekman_magsafe-buskill'

        try:
            with open(f'{report_path}/sonarcloud-issues.json', 'r') as f:
                data = json.load(f)
            
            issues = data.get('issues', [])
            
            # Generate report
            with open(f'{report_path}/sonarcloud-findings.txt', 'w') as report:
                report.write(f'=== SonarCloud Findings Report ===\
        ')
                report.write(f'Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}\
        ')
                report.write(f'Project: {project_key}\
        ')
                report.write(f'Total issues: {len(issues)}\
        \
        ')
                
                # Group by severity
                by_severity = {}
                for issue in issues:
                    severity = issue.get('severity', 'UNKNOWN')
                    if severity not in by_severity:
                        by_severity[severity] = []
                    by_severity[severity].append(issue)
                
                # Write issues by severity
                for severity in ['BLOCKER', 'CRITICAL', 'MAJOR', 'MINOR', 'INFO']:
                    if severity not in by_severity:
                        continue
                    
                    report.write(f'\
        {"=" * 50}\
        ')
                    report.write(f'{severity} ISSUES ({len(by_severity[severity])})\
        ')
                    report.write(f'{"=" * 50}\
        \
        ')
                    
                    for issue in by_severity[severity]:
                        component = issue.get('component', 'unknown').replace(f'{project_key}:', '')
                        line = issue.get('textRange', {}).get('startLine', 0)
                        
                        report.write(f'[{issue.get("type", "UNKNOWN")}] {component}:{line}\
        ')
                        report.write(f'  Rule: {issue.get("rule", "unknown")}\
        ')
                        report.write(f'  Message: {issue.get("message", "No message")}\
        ')
                        
                        # Add effort if available
                        effort = issue.get('effort')
                        if effort:
                            report.write(f'  Effort: {effort}\
        ')
                        
                        # Add status
                        status = issue.get('status', 'OPEN')
                        if status != 'OPEN':
                            report.write(f'  Status: {status}\
        ')
                        
                        report.write('\
        ')
            
            print(f'✅ Successfully processed {len(issues)} issues')
            
        except Exception as e:
            print(f'Error processing SonarCloud response: {e}')
            sys.exit(1)
        SCRIPT_EOF

        python3 {{.REPORT_PATH}}/process_issues.py || exit 1
        rm -f {{.REPORT_PATH}}/process_issues.py

        echo ""
        echo "\U0001F4CA Summary:"

        # Create temp Python script for summary
        cat > {{.REPORT_PATH}}/summary.py << 'SCRIPT_EOF'
        import json
        import sys

        report_path = '.sonarcloud'

        with open(f'{report_path}/sonarcloud-issues.json', 'r') as f:
            data = json.load(f)
            issues = data.get('issues', [])
            
            # Count by type
            types = {}
            severities = {}
            for issue in issues:
                issue_type = issue.get('type', 'UNKNOWN')
                severity = issue.get('severity', 'UNKNOWN')
                types[issue_type] = types.get(issue_type, 0) + 1
                severities[severity] = severities.get(severity, 0) + 1
            
            print('By Type:')
            for t, count in sorted(types.items()):
                print(f'  - {t}: {count}')
            
            print('\
        By Severity:')
            for s in ['BLOCKER', 'CRITICAL', 'MAJOR', 'MINOR', 'INFO']:
                if s in severities:
                    print(f'  - {s}: {severities[s]}')
        SCRIPT_EOF

        python3 {{.REPORT_PATH}}/summary.py
        rm -f {{.REPORT_PATH}}/summary.py

        echo ""
        echo "✅ Download completed"
        echo ""
        echo "Results saved to:"
        echo "  - Full JSON: {{.REPORT_PATH}}/sonarcloud-issues.json"
        echo "  - Readable report: {{.REPORT_PATH}}/sonarcloud-findings.txt"
        echo ""
        echo "To view the report: cat {{.REPORT_PATH}}/sonarcloud-findings.txt | less"

  download:pr:
    desc: Download SonarCloud pull request report (use PR=123 to specify PR number)
    silent: true
    vars:
      REPORT_PATH: .sonarcloud
      PROJECT_KEY: lekman_magsafe-buskill
      ORGANIZATION: lekman
      SONAR_API_BASE: https://sonarcloud.io/api
    cmds:
      - |
        echo "\U0001F4E5 Downloading SonarCloud pull request report..."

        # Show usage if help is requested
        if [ "${PR}" = "help" ] || [ "${PR}" = "--help" ]; then
          echo ""
          echo "Usage:"
          echo "  task sonar:download:pr         # Interactive mode - choose from list"
          echo "  PR=123 task sonar:download:pr  # Download specific PR"
          echo "  PR=latest task sonar:download:pr  # Download latest PR (non-interactive)"
          echo ""
          exit 0
        fi

        # Source .env file if it exists
        if [ -f .env ]; then
          set -a
          source .env
          set +a
        fi

        # Check for SONAR_TOKEN
        if [ -z "$SONAR_TOKEN" ]; then
          echo "❌ SONAR_TOKEN environment variable is not set"
          echo ""
          echo "To download SonarCloud findings, you need to:"
          echo "1. Get your token from: https://sonarcloud.io/account/security"
          echo "2. Add it to your .env file:"
          echo "   echo 'SONAR_TOKEN=your-token-here' >> .env"
          echo "3. Run this task again"
          exit 1
        fi

        # Get current branch for reference
        CURRENT_BRANCH=$(git branch --show-current)

        # Get PR number from CLI args or try to detect
        PR_NUMBER="${PR:-}"
        PR_TITLE=""
        PR_BRANCH=""

        # First, list all pull requests
        echo "\U0001F4CB Fetching pull requests from SonarCloud..."
        PR_LIST=$(curl -s -X GET \\
          "{{.SONAR_API_BASE}}/project_pull_requests/list?project={{.PROJECT_KEY}}" \\
          -H "Authorization: Bearer $SONAR_TOKEN")

        if [ $? -ne 0 ] || [ -z "$PR_LIST" ]; then
          echo "❌ Failed to fetch pull request list"
          exit 1
        fi

        # Handle "latest" keyword
        if [ "$PR_NUMBER" = "latest" ]; then
          PR_NUMBER=$(echo "$PR_LIST" | jq -r '.pullRequests[0].key' 2>/dev/null || echo "")
          if [ -n "$PR_NUMBER" ]; then
            echo "\U0001F4CC Using latest PR: #$PR_NUMBER"
          else
            echo "❌ No pull requests found"
            exit 1
          fi
        elif [ -z "$PR_NUMBER" ]; then
          echo "\U0001F50D Current git branch: $CURRENT_BRANCH"
          
          # Display available PRs
          echo ""
          echo "Available pull requests:"
          echo "$PR_LIST" | jq -r '.pullRequests[] | "  PR #\\(.key): \\(.title) [\\(.status)]"' 2>/dev/null || echo "  Unable to parse PR list"
          
          echo ""
          echo "Enter PR number, 'latest' for most recent, or press Enter to choose latest:"
          read -p "PR selection: " PR_NUMBER
          
          # If still empty or "latest", get the latest PR
          if [ -z "$PR_NUMBER" ] || [ "$PR_NUMBER" = "latest" ]; then
            PR_NUMBER=$(echo "$PR_LIST" | jq -r '.pullRequests[0].key' 2>/dev/null || echo "")
            if [ -n "$PR_NUMBER" ]; then
              echo "\U0001F4CC Using latest PR: #$PR_NUMBER"
            else
              echo "❌ No pull requests found"
              exit 1
            fi
          fi
        else
          echo "\U0001F4CC Using specified PR: #$PR_NUMBER"
        fi

        # Extract PR details
        PR_DATA=$(echo "$PR_LIST" | jq -r ".pullRequests[] | select(.key == \\"$PR_NUMBER\\")" 2>/dev/null)
        if [ -n "$PR_DATA" ]; then
          PR_TITLE=$(echo "$PR_DATA" | jq -r '.title' 2>/dev/null || echo "")
          PR_BRANCH=$(echo "$PR_DATA" | jq -r '.branch' 2>/dev/null || echo "")
        fi

        # Create report directory
        mkdir -p {{.REPORT_PATH}}

        echo "\U0001F50D Fetching PR #$PR_NUMBER analysis..."

        # Function to make API calls
        api_call() {
          local endpoint="$1"
          curl -s -H "Authorization: Bearer $SONAR_TOKEN" "{{.SONAR_API_BASE}}/$endpoint"
        }

        # Get PR issues
        echo "\U0001F4CB Fetching PR issues..."
        ISSUES_DATA=$(api_call "issues/search?pullRequest=$PR_NUMBER&componentKeys={{.PROJECT_KEY}}&resolved=false")
        echo "$ISSUES_DATA" > "{{.REPORT_PATH}}/pr-$PR_NUMBER-issues.json"

        # Get PR measures
        echo "\U0001F4CA Fetching PR measures..."
        MEASURES_DATA=$(api_call "measures/component?component={{.PROJECT_KEY}}&pullRequest=$PR_NUMBER&metricKeys=bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density")
        echo "$MEASURES_DATA" > "{{.REPORT_PATH}}/pr-$PR_NUMBER-measures.json"

        # Process to Markdown
        echo "\U0001F4DD Generating markdown report..."

        # Extract data for report
        TOTAL_ISSUES=$(echo "$ISSUES_DATA" | jq -r '.total' 2>/dev/null || echo "0")
        BUGS=$(echo "$MEASURES_DATA" | jq -r '.component.measures[] | select(.metric == "bugs") | .value' 2>/dev/null || echo "N/A")
        VULNERABILITIES=$(echo "$MEASURES_DATA" | jq -r '.component.measures[] | select(.metric == "vulnerabilities") | .value' 2>/dev/null || echo "N/A")
        CODE_SMELLS=$(echo "$MEASURES_DATA" | jq -r '.component.measures[] | select(.metric == "code_smells") | .value' 2>/dev/null || echo "N/A")
        COVERAGE=$(echo "$MEASURES_DATA" | jq -r '.component.measures[] | select(.metric == "coverage") | .value' 2>/dev/null || echo "N/A")
        DUPLICATION=$(echo "$MEASURES_DATA" | jq -r '.component.measures[] | select(.metric == "duplicated_lines_density") | .value' 2>/dev/null || echo "N/A")

        # Create markdown report using echo to avoid YAML parsing issues
        {
          echo "# SonarCloud Analysis Report"
          echo ""
          echo "**Project:** {{.PROJECT_KEY}}  "
          echo "**Organization:** {{.ORGANIZATION}}  "
          echo "**Pull Request:** #$PR_NUMBER${PR_TITLE:+ - $PR_TITLE}  "
          echo "**Branch:** ${PR_BRANCH:-Unknown}  "
          echo "**Current Git Branch:** $CURRENT_BRANCH  "
          echo "**Generated:** $(date)  "
          echo ""
          echo "## Quality Metrics"
          echo ""
          echo "| Metric | Value |"
          echo "|--------|-------|"
          echo "| \U0001F41B Bugs | $BUGS |"
          echo "| \U0001F512 Vulnerabilities | $VULNERABILITIES |"
          echo "| \U0001F32B️ Code Smells | $CODE_SMELLS |"
          echo "| \U0001F4CA Coverage | ${COVERAGE}% |"
          echo "| \U0001F4CB Duplication | ${DUPLICATION}% |"
          echo ""
          echo "## Issues ($TOTAL_ISSUES)"
          echo ""
        } > "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"

        if [[ "$TOTAL_ISSUES" -gt 0 ]]; then
          echo "### By Severity" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
          echo "" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
          
          for severity in BLOCKER CRITICAL MAJOR MINOR INFO; do
            COUNT=$(echo "$ISSUES_DATA" | jq -r ".issues[] | select(.severity == \\"$severity\\") | .key" 2>/dev/null | wc -l | tr -d ' ')
            if [[ "$COUNT" -gt 0 ]]; then
              echo "- **$severity**: $COUNT issues" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
            fi
          done
          
          echo "" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
          echo "### Issue Details" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
          echo "" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
          
          # List issues (limit to first 50)
          echo "$ISSUES_DATA" | jq -r '.issues[] | "- **\\(.severity)** [\\(.rule)](\\(.htmlText)): \\(.message) (`\\(.component | split("/") | last):\\(.line)`)"' 2>/dev/null | head -50 >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md" || true
          
          REMAINING=$((TOTAL_ISSUES - 50))
          if [[ $REMAINING -gt 0 ]]; then
            echo "" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
            echo "*... and $REMAINING more issues*" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
          fi
        else
          echo "*No issues found! \U0001F389*" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
        fi

        echo "" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
        echo "---" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
        echo "[View full report on SonarCloud](https://sonarcloud.io/pullrequests/overview?id={{.PROJECT_KEY}}&pullRequest=$PR_NUMBER)" >> "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"

        echo ""
        echo "✅ PR report downloaded"
        echo ""
        echo "Results saved to:"
        echo "  - Markdown report: {{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"
        echo "  - Issues JSON: {{.REPORT_PATH}}/pr-$PR_NUMBER-issues.json"
        echo "  - Measures JSON: {{.REPORT_PATH}}/pr-$PR_NUMBER-measures.json"
        echo ""
        echo "\U0001F4C2 Opening report in VSCode..."
        code "{{.REPORT_PATH}}/pr-$PR_NUMBER-report.md"

  convert:
    desc: Convert Swift coverage to SonarQube generic XML format
    silent: true
    cmds:
      - |
        echo "\U0001F504 Converting Swift coverage to SonarQube format..."

        # Check if coverage.xml already exists
        if [ -f "coverage.xml" ]; then
          echo "✅ coverage.xml already exists - no conversion needed"
          exit 0
        fi

        # First, run tests with coverage if needed
        if [ ! -d ".build" ] || [ -z "$(find .build -name 'default.profdata' -type f 2>/dev/null)" ]; then
          echo "\U0001F9EA Running tests with coverage..."
          swift test --enable-code-coverage
        fi

        # Find the coverage data
        PROF_DATA=$(find .build -name 'default.profdata' -type f | head -1)
        EXECUTABLE=$(find .build -name 'MagSafeGuardPackageTests.xctest' -type d | head -1)/Contents/MacOS/MagSafeGuardPackageTests

        if [[ -f "$PROF_DATA" && -f "$EXECUTABLE" ]]; then
          echo "\U0001F4CA Generating SonarQube generic coverage XML..."
          
          # Generate the coverage XML directly (avoiding function definition in YAML)
          {
            echo '<coverage version="1">'
            xcrun llvm-cov show "$EXECUTABLE" \\
              -instr-profile="$PROF_DATA" \\
              -use-color=false \\
              -ignore-filename-regex=".*Tests\\.swift|.*Mocks?\\.swift|.*/MagSafeGuardApp\\.swift|.*/PowerMonitorService\\.swift|.*/PowerMonitorCore\\.swift|.*LAContext\\.swift|.*/MacSystemActions\\.swift|.*Protocol\\.swift" | \\
            awk '
              /^[[:space:]]*[^[:space:]]+:$/ {
                if (in_file) print "  </file>"
                gsub(/:$/, "", $1)
                gsub(/&/, "\\\\&amp;", $1)
                print "  <file path=\\"" $1 "\\">"
                in_file = 1
                next
              }
              /^[[:space:]]*[0-9]+\\|/ {
                split($0, parts, "|")
                linenum = parts[1]
                gsub(/^[[:space:]]+/, "", linenum)
                gsub(/[[:space:]]+$/, "", linenum)
                
                # Check if line is covered (has execution count)
                if (match(parts[2], /^[[:space:]]*[0-9]+/)) {
                  print "    <lineToCover lineNumber=\\"" linenum "\\" covered=\\"true\\"/>"
                } else if (match(parts[2], /^[[:space:]]*0/)) {
                  print "    <lineToCover lineNumber=\\"" linenum "\\" covered=\\"false\\"/>"
                }
              }
              END {
                if (in_file) print "  </file>"
              }
            '
            echo '</coverage>'
          } > coverage.xml
          
          if [ -f "coverage.xml" ] && [ -s "coverage.xml" ]; then
            echo "✅ Successfully generated coverage.xml"
            echo "   File size: $(wc -c < coverage.xml) bytes"
            echo "   Files covered: $(grep -c '<file path=' coverage.xml || echo 0)"
          else
            echo "❌ Failed to create coverage.xml or file is empty"
            exit 1
          fi
        else
          echo "❌ Coverage data not found"
          echo "PROF_DATA: $PROF_DATA"
          echo "EXECUTABLE: $EXECUTABLE"
          exit 1
        fi

  setup:
    desc: Setup SonarCloud scanner
    silent: true
    cmds:
      - |
        echo "\U0001F527 Setting up SonarCloud scanner..."

        # Check if already installed
        if command -v sonar-scanner &> /dev/null; then
          echo "✅ sonar-scanner already installed ($(sonar-scanner -v | grep -oE '[0-9]+\\.[0-9]+\\.[0-9]+' | head -1))"
          
          # Check for updates on macOS
          if command -v brew &> /dev/null && brew list sonar-scanner &>/dev/null; then
            if brew outdated | grep -q "^sonar-scanner"; then
              echo "\U0001F4E6 Updating sonar-scanner..."
              brew upgrade sonar-scanner
            fi
          fi
          exit 0
        fi

        # Detect OS for fresh installation
        OS=$(uname -s | tr '[:upper:]' '[:lower:]')

        if [ "$OS" = "darwin" ]; then
          # macOS
          if command -v brew &> /dev/null; then
            echo "\U0001F4E6 Installing via Homebrew..."
            brew install sonar-scanner
          else
            echo "❌ Homebrew not found. Please install Homebrew first:"
            echo "   /bin/bash -c \\"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\\""
            exit 1
          fi
        elif [ "$OS" = "linux" ]; then
          # Linux
          echo "\U0001F4E6 Installing SonarCloud scanner for Linux..."
          
          # Check if running in CI or local
          if [ -n "$CI" ] || [ ! -w "/usr/local" ]; then
            # Download to local directory
            INSTALL_DIR="$HOME/.local/bin"
            mkdir -p "$INSTALL_DIR"
            
            echo "⬇️  Downloading sonar-scanner..."
            curl -sSL https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-4.8.0.2856-linux.zip -o /tmp/sonar-scanner.zip
            
            echo "\U0001F4C2 Extracting..."
            unzip -q /tmp/sonar-scanner.zip -d /tmp/
            mv /tmp/sonar-scanner-*/* "$INSTALL_DIR/"
            rm -rf /tmp/sonar-scanner*
            
            echo "✅ Installed to $INSTALL_DIR"
            echo "⚠️  Make sure $INSTALL_DIR is in your PATH"
          else
            # System-wide install
            echo "⬇️  Downloading sonar-scanner..."
            curl -sSL https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-4.8.0.2856-linux.zip -o /tmp/sonar-scanner.zip
            
            echo "\U0001F4C2 Extracting..."
            sudo unzip -q /tmp/sonar-scanner.zip -d /opt/
            sudo ln -sf /opt/sonar-scanner-*/bin/sonar-scanner /usr/local/bin/sonar-scanner
            rm /tmp/sonar-scanner.zip
            
            echo "✅ Installed system-wide"
          fi
        else
          echo "❌ Unsupported OS: $OS"
          echo "Please install manually from:"
          echo "https://docs.sonarcloud.io/advanced-setup/ci-based-analysis/sonarscanner-cli/"
          exit 1
        fi

        # Verify installation
        if command -v sonar-scanner &> /dev/null; then
          echo ""
          echo "✅ SonarCloud scanner installed successfully!"
          sonar-scanner -v
        else
          echo "⚠️  Installation completed but sonar-scanner not found in PATH"
          echo "You may need to restart your terminal or add the installation directory to PATH"
        fi
