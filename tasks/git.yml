# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: "3"
vars:
  # Color codes for output
  CYAN: '\033[0;36m'
  GREEN: '\033[0;32m'
  YELLOW: '\033[0;33m'
  RED: '\033[0;31m'
  NC: '\033[0m' # No Color
  # Dynamically determine the base path for templates
  TEMPLATE_PATH:
    sh: |
      if [ -f ".tasks/common/templates/prepare-commit-msg.template" ]; then
        echo ".tasks/common/templates/prepare-commit-msg.template"
      elif [ -f "tasks/common/templates/prepare-commit-msg.template" ]; then
        echo "tasks/common/templates/prepare-commit-msg.template"
      elif [ -f "node_modules/@evinova/devops-tasks/common/templates/prepare-commit-msg.template" ]; then
        echo "node_modules/@evinova/devops-tasks/common/templates/prepare-commit-msg.template"
      else
        echo ".tasks/common/templates/prepare-commit-msg.template"
      fi
  # Valid workflow statuses
  VALID_STATUSES: "queued completed in_progress requested waiting action_required cancelled failure neutral skipped stale startup_failure success timed_out"
tasks:
  # Internal task to load .env file
  load-env:
    internal: true
    silent: true
    cmds:
      - "# Check if .env file exists\nif [ -f \".env\" ]; then\n  # Source the .env file\n  set -a\n  source .env\n  set +a\n  \n  # Verify GITHUB_TOKEN is set\n  if [ -z \"${GITHUB_TOKEN}\" ]; then\n    echo -e \"{{.RED}}Error: GITHUB_TOKEN not found in .env file{{.NC}}\"\n    echo \"\"\n    echo \"Please add your GitHub token to the .env file:\"\n    echo \"\"\n    echo \"1. Create a GitHub personal access token:\"\n    echo \"   https://github.com/settings/tokens/new\"\n    echo \"\"\n    echo \"2. Add it to your .env file:\"\n    echo \"   echo 'GITHUB_TOKEN=ghp_your_token_here' >> .env\"\n    echo \"\"\n    echo \"3. Or authenticate using GitHub CLI (recommended):\"\n    echo \"   gh auth login\"\n    echo \"\"\n    exit 1\n  fi\nelse\n  # .env doesn't exist, check if gh CLI is authenticated\n  if command -v gh &> /dev/null && gh auth status &>/dev/null; then\n    # gh CLI is authenticated, we can proceed\n    export GITHUB_TOKEN=$(gh auth token)\n  else\n    echo -e \"{{.RED}}Error: No authentication found{{.NC}}\"\n    echo \"\"\n    echo \"You need to either:\"\n    echo \"\"\n    echo \"Option 1: Create a .env file with your GitHub token:\"\n    echo \"   echo 'GITHUB_TOKEN=ghp_your_token_here' >> .env\"\n    echo \"\"\n    echo \"Option 2: Authenticate using GitHub CLI (recommended):\"\n    echo \"   brew install gh\"\n    echo \"   gh auth login\"\n    echo \"\"\n    echo \"To create a GitHub personal access token:\"\n    echo \"   https://github.com/settings/tokens/new\"\n    echo \"\"\n    echo \"Required scopes: repo, read:org (for private repos)\"\n    echo \"\"\n    exit 1\n  fi\nfi\n"
  # Internal task to check if gh CLI is installed
  check-gh-cli:
    internal: true
    silent: true
    cmds:
      - |
        if ! command -v gh &> /dev/null; then
          echo -e "{{.RED}}GitHub CLI (gh) is not installed{{.NC}}"
          echo "Please install it first:"
          echo "  brew install gh"
          exit 1
        fi
  # Internal task to ensure GitHub authentication is configured for gh CLI
  ensure-gh-auth:
    internal: true
    silent: true
    deps: [load-env, check-gh-cli]
    cmds:
      - |
        # Check if gh is already authenticated
        if ! gh auth status &>/dev/null; then
          # Not authenticated, but we should have GITHUB_TOKEN from load-env
          if [ -n "${GITHUB_TOKEN}" ]; then
            # Export token for gh CLI to use
            export GH_TOKEN="${GITHUB_TOKEN}"
          else
            echo -e "{{.RED}}GitHub authentication required{{.NC}}"
            echo "Please authenticate with: gh auth login"
            exit 1
          fi
        fi
  default:
    desc: List all Git tasks
    silent: true
    cmds:
      - task --list | grep "^\\* git:" | grep -v "::" || true
  # Change to repository root
  cd-root:
    desc: Change to the repository root directory
    silent: true
    cmds:
      - |
        ROOT_DIR=$(git rev-parse --show-toplevel)
        if [ -z "$ROOT_DIR" ]; then
          echo "Error: Not in a git repository"
          exit 1
        fi
        cd "$ROOT_DIR"
  # Get repository root path
  get-root:
    desc: Get the absolute path to the repository root
    silent: true
    cmds:
      - |
        ROOT_DIR=$(git rev-parse --show-toplevel)
        if [ -z "$ROOT_DIR" ]; then
          echo "Error: Not in a git repository"
          exit 1
        fi
        echo "$ROOT_DIR"
  # Delete local branches that don't have a remote counterpart
  prune:
    desc: Delete local branches that don't have a remote counterpart
    silent: true
    vars:
      BASE_DIR: '{{.BASE_DIR | default "."}}'
    cmds:
      - "# Color codes\nCYAN='\\033[0;36m'\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nNC='\\033[0m'\n\n# Find all .git directories and iterate over them\nfind \"{{.BASE_DIR}}\" -type d -name \".git\" | while read -r git_dir; do\n  # Get the parent directory of the .git folder\n  repo_dir=$(dirname \"$git_dir\")\n  \n  echo -e \"${CYAN}Processing:${NC} $repo_dir\"\n  \n  # Navigate to the repository directory\n  cd \"$repo_dir\" || {\n    echo \"Failed to navigate to $repo_dir. Skipping.\"\n    continue\n  }\n  \n  # Get the default branch name - check if it's set first\n  if ! git symbolic-ref refs/remotes/origin/HEAD >/dev/null 2>&1; then\n    echo \"Setting default branch...\"\n    # Try to set it based on common branch names\n    if git show-ref --verify --quiet refs/remotes/origin/main; then\n      git symbolic-ref refs/remotes/origin/HEAD refs/remotes/origin/main\n    elif git show-ref --verify --quiet refs/remotes/origin/master; then\n      git symbolic-ref refs/remotes/origin/HEAD refs/remotes/origin/master\n    else\n      echo \"Could not determine default branch. Skipping.\"\n      continue\n    fi\n  fi\n  \n  default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')\n  \n  if [ -z \"$default_branch\" ]; then\n    echo \"Could not determine default branch. Skipping.\"\n    continue\n  fi\n  \n  # Switch to the default branch\n  echo \"Switching to $default_branch branch...\"\n  if ! git checkout \"$default_branch\" >/dev/null 2>&1; then\n    echo \"Failed to checkout $default_branch. Skipping.\"\n    continue\n  fi\n  \n  # Fetch and prune\n  echo \"Fetching and pruning remote branches...\"\n  if ! git fetch -p >/dev/null 2>&1; then\n    echo \"Failed to fetch from remote. Skipping.\"\n    continue\n  fi\n  \n  # Fetch local branches that are gone on remote\n  branches_to_delete=$(git branch -vv | grep ': gone]' | sed 's/^\\* //;s/^[[:space:]]*//;s/[[:space:]]*$//' | cut -d ' ' -f 1)\n  \n  if [ -n \"$branches_to_delete\" ]; then\n    echo \"Found branches to delete:\"\n    echo \"$branches_to_delete\" | while read -r branch; do\n      if [ -n \"$branch\" ]; then\n        echo -e \"${RED}  - $branch${NC}\"\n        git branch -D \"$branch\"\n      fi\n    done\n  else\n    echo \"No branches to delete.\"\n  fi\n  \n  echo -e \"${GREEN}Done${NC}\"\n  \n  cd \"$OLDPWD\" || {\n    echo \"Failed to navigate back.\"\n    break\n  }\ndone\n\necho \"All repositories processed.\"\n"
    aliases: [clean-branches, clb]
  # Fetch and prune remote branches
  fetch-prune:
    desc: Fetch and prune remote branches
    silent: true
    cmds:
      - git fetch -p
    aliases: [fp]
  # Switch to default branch
  switch-default:
    desc: Switch to the default branch
    silent: true
    cmds:
      - |
        default_branch=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')
        git checkout "$default_branch"
    aliases: [sd]
  # List all branches
  list-branches:
    desc: List all branches with their status
    silent: true
    cmds:
      - git --no-pager branch -vv
    aliases: [lb]
  # Delete GitHub workflow runs
  delete-runs:
    desc: Delete GitHub workflow runs for a branch with specific status
    silent: true
    deps: [check-gh-cli]
    dotenv: ['.env']
    vars:
      BRANCH: '{{.BRANCH | default ""}}'
      STATUS: '{{.STATUS | default "failure"}}'
    cmds:
      - "# Set up authentication - prefer gh CLI auth, fallback to GITHUB_TOKEN\nif ! gh auth status &>/dev/null; then\n  # Not authenticated via gh CLI, check for token from .env\n  if [ -n \"${GITHUB_TOKEN}\" ]; then\n    export GH_TOKEN=\"${GITHUB_TOKEN}\"\n  else\n    echo -e \"{{.RED}}GitHub authentication required{{.NC}}\"\n    echo \"Please either:\"\n    echo \"  1. Add GITHUB_TOKEN to your .env file\"\n    echo \"  2. Or authenticate with: gh auth login\"\n    exit 1\n  fi\nfi\n\n# Validate status\nif [[ ! \"{{.VALID_STATUSES}}\" =~ {{.STATUS}} ]]; then\n  echo -e \"{{.RED}}Invalid status: {{.STATUS}}{{.NC}}\"\n  echo \"Use one of:\"\n  echo \"  {{.VALID_STATUSES}}\"\n  exit 1\nfi\n\n# Get repository info from GitHub\nrepo_owner=$(gh repo view --json owner --jq '.owner.login')\nrepo_name=$(gh repo view --json name --jq '.name')\n\n# If no branch specified, use current branch\nbranch=\"{{.BRANCH}}\"\nif [ -z \"$branch\" ]; then\n  branch=$(git rev-parse --abbrev-ref HEAD)\nfi\n\necho -e \"{{.CYAN}}Using repository: $repo_owner/$repo_name{{.NC}}\"\n\n# Handle all branches case\nif [ \"$branch\" == \"all\" ] || [ \"$branch\" == \"-all\" ] || [ \"$branch\" == \"--all\" ] || [ \"$branch\" == \"-a\" ]; then\n  echo -e \"{{.CYAN}}Processing runs in all branches...{{.NC}}\"\n  workflow_runs=$(gh run list -R \"$repo_owner/$repo_name\" -a -s {{.STATUS}} --limit 100 --json databaseId)\nelse    \n  echo -e \"{{.CYAN}}Processing runs in branch $branch...{{.NC}}\"\n  workflow_runs=$(gh run list -R \"$repo_owner/$repo_name\" -b \"$branch\" -a -s {{.STATUS}} --limit 100 --json databaseId)\nfi\n\n# Parse and delete runs\nrun_ids=$(echo \"$workflow_runs\" | jq -r '.[].databaseId')\ndeleted=0\nfor run_id in $run_ids; do\n  gh run delete $run_id\n  deleted=$((deleted+1))\ndone\n\n# Report results\nif [ $deleted -eq 0 ]; then\n  echo -e \"{{.YELLOW}}No runs found with status {{.STATUS}} in branch $branch{{.NC}}\"\nelse\n  echo -e \"{{.GREEN}}Deleted $deleted runs with status {{.STATUS}} in branch $branch{{.NC}}\"\nfi\n"
    aliases: [dr]
  # Dependabot vulnerability analysis
  cve:analyze:
    desc: "Quick vulnerability scan using GitHub Dependabot API (requires gh CLI)"
    silent: true
    deps: [check-gh-cli]
    dotenv: ['.env']
    vars:
      MIN_SEVERITY: '{{.MIN_SEVERITY | default "medium"}}'
      LOG_DIR: "./logs/vulnerabilities"
    cmds:
      - "# Set up authentication - prefer gh CLI auth, fallback to GITHUB_TOKEN\nif ! gh auth status &>/dev/null; then\n  # Not authenticated via gh CLI, check for token from .env\n  if [ -n \"${GITHUB_TOKEN}\" ]; then\n    export GH_TOKEN=\"${GITHUB_TOKEN}\"\n  else\n    echo -e \"{{.RED}}GitHub authentication required{{.NC}}\"\n    echo \"Please either:\"\n    echo \"  1. Add GITHUB_TOKEN to your .env file\"\n    echo \"  2. Or authenticate with: gh auth login\"\n    exit 1\n  fi\nfi\n\n# Clean up old vulnerability logs\nif [ -d \"{{.LOG_DIR}}\" ]; then\n  find \"{{.LOG_DIR}}\" -type f -name 'vulns-*.*' -exec rm -f {} \\;\nfi\n\n# Get minimum severity level (default: medium)\nMIN_SEVERITY={{.MIN_SEVERITY}}\n\n# Validate severity level\ncase \"$MIN_SEVERITY\" in\n  critical|high|medium|low)\n    ;;\n  *)\n    echo -e \"{{.RED}}Invalid MIN_SEVERITY: $MIN_SEVERITY{{.NC}}\"\n    echo \"Valid values: critical, high, medium, low\"\n    echo \"Example: task git:cve:analyze MIN_SEVERITY=low\"\n    exit 1\n    ;;\nesac\n\n# Get repository info\nREPO=$(gh repo view --json nameWithOwner --jq '.nameWithOwner')\n\necho -e \"{{.CYAN}}Checking vulnerabilities for: $REPO{{.NC}}\"\necho -e \"{{.CYAN}}Minimum severity: $MIN_SEVERITY and above{{.NC}}\"\n\n# Get vulnerabilities using gh CLI\nVULNS_RAW=$(gh api \"/repos/$REPO/dependabot/alerts\" 2>&1)\nif [ $? -ne 0 ]; then\n  echo -e \"{{.RED}}Failed to fetch vulnerabilities{{.NC}}\"\n  echo \"$VULNS_RAW\"\n  exit 1\nfi\n\n# Clean and process JSON\nVULNS_CLEAN=$(echo \"$VULNS_RAW\" | tr -d '\\000-\\010\\013-\\037')\n\n# Extract vulnerability information\nVULNS_ALL=$(echo \"$VULNS_CLEAN\" | jq --arg min_sev \"$MIN_SEVERITY\" '[\n  .[] | select(.state==\"open\") | {\n    cve: (.security_advisory.cve_id // null),\n    pkg: (.security_vulnerability.package.name // \"unknown\"),\n    ecosystem: (.security_vulnerability.package.ecosystem // \"unknown\"),\n    sev: (.security_vulnerability.severity // \"unknown\"),\n    current_version: (.security_vulnerability.vulnerable_version_range // null),\n    fixed_version: (.security_vulnerability.first_patched_version.identifier // null),\n    manifest_path: (.dependency.manifest_path // null),\n    summary: (.security_advisory.summary // null),\n    ghsa_id: (.security_advisory.ghsa_id // null),\n    cvss_score: (.security_advisory.cvss.score // null),\n    created_at: (.created_at // null)\n  } | \n  # Filter based on minimum severity\n  select(\n    if $min_sev == \"low\" then true\n    elif $min_sev == \"medium\" then (.sev == \"medium\" or .sev == \"high\" or .sev == \"critical\")\n    elif $min_sev == \"high\" then (.sev == \"high\" or .sev == \"critical\")\n    elif $min_sev == \"critical\" then .sev == \"critical\"\n    else true end\n  )\n] | sort_by(\n  if .sev == \"critical\" then 0\n  elif .sev == \"high\" then 1\n  elif .sev == \"medium\" then 2\n  elif .sev == \"low\" then 3\n  else 4 end\n)' 2>/dev/null || echo \"[]\")\n\n# Create deduplicated list\nVULNS=$(echo \"$VULNS_ALL\" | jq 'group_by((.cve // .ghsa_id // \"NO-ID\") + \":\" + .pkg) | \n  map({\n    cve: .[0].cve,\n    pkg: .[0].pkg,\n    ecosystem: .[0].ecosystem,\n    sev: .[0].sev,\n    current_version: .[0].current_version,\n    fixed_version: .[0].fixed_version,\n    summary: .[0].summary,\n    ghsa_id: .[0].ghsa_id,\n    cvss_score: .[0].cvss_score,\n    manifest_paths: [.[] | .manifest_path] | unique | sort,\n    count: length\n  }) | sort_by(\n  if .sev == \"critical\" then 0\n  elif .sev == \"high\" then 1\n  elif .sev == \"medium\" then 2\n  elif .sev == \"low\" then 3\n  else 4 end\n)' 2>/dev/null || echo \"[]\")\n\nVULN_COUNT=$(echo \"$VULNS\" | jq 'length' 2>/dev/null || echo \"0\")\n\n# Save results\nmkdir -p {{.LOG_DIR}}\nTIMESTAMP=$(date +%Y%m%d-%H%M%S)\nRAW_FILE=\"{{.LOG_DIR}}/vulns-${TIMESTAMP}-raw.json\"\nLOG_FILE=\"{{.LOG_DIR}}/vulns-${TIMESTAMP}.json\"\nSUMMARY_FILE=\"{{.LOG_DIR}}/vulns-${TIMESTAMP}-summary.txt\"\n\necho \"$VULNS_RAW\" > \"$RAW_FILE\"\necho \"$VULNS\" > \"$LOG_FILE\"\n\n# Create summary\n{\n  echo \"=== Security Vulnerability Report ===\"\n  echo \"Date: $(date)\"\n  echo \"Repository: $REPO\"\n  echo \"Minimum severity: $MIN_SEVERITY and above\"\n  echo \"Vulnerabilities found: $VULN_COUNT\"\n  echo \"\"\n  \n  if [ \"$VULN_COUNT\" -gt \"0\" ]; then\n    # Count by severity\n    CRITICAL_COUNT=$(echo \"$VULNS\" | jq '[.[] | select(.sev == \"critical\")] | length' 2>/dev/null || echo \"0\")\n    HIGH_COUNT=$(echo \"$VULNS\" | jq '[.[] | select(.sev == \"high\")] | length' 2>/dev/null || echo \"0\")\n    MEDIUM_COUNT=$(echo \"$VULNS\" | jq '[.[] | select(.sev == \"medium\")] | length' 2>/dev/null || echo \"0\")\n    LOW_COUNT=$(echo \"$VULNS\" | jq '[.[] | select(.sev == \"low\")] | length' 2>/dev/null || echo \"0\")\n    \n    echo \"Severity breakdown:\"\n    [ \"$CRITICAL_COUNT\" -gt 0 ] && echo \"  - Critical: $CRITICAL_COUNT\"\n    [ \"$HIGH_COUNT\" -gt 0 ] && echo \"  - High: $HIGH_COUNT\"\n    [ \"$MEDIUM_COUNT\" -gt 0 ] && echo \"  - Medium: $MEDIUM_COUNT\"\n    [ \"$LOW_COUNT\" -gt 0 ] && echo \"  - Low: $LOW_COUNT\"\n    echo \"\"\n    \n    echo \"Vulnerabilities (sorted by severity):\"\n    echo \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\"\n    echo \"\"\n    \n    echo \"$VULNS\" | jq -r '.[] | \n      \"CVE: \\(.cve // .ghsa_id // \"NO-ID\")\\n\" +\n      \"Severity: \\(.sev | ascii_upcase) (CVSS: \\(.cvss_score // \"N/A\"))\\n\" +\n      \"Package: \\(.ecosystem)/\\(.pkg)\\n\" +\n      \"Locations (\\(.count)):\\n\" +\n      (.manifest_paths | map(\"  - \" + .) | join(\"\\n\")) + \"\\n\" +\n      \"Current: \\(.current_version // \"Unknown\")\\n\" +\n      \"Fixed in: \\(.fixed_version // \"No fix available\")\\n\" +\n      \"Summary: \\(.summary // \"No description available\" | .[0:200])\\n\" +\n      \"━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\\n\"'\n  else\n    echo \"No vulnerabilities found.\"\n  fi\n} > \"$SUMMARY_FILE\"\n\n# Display results\nif [ \"$VULN_COUNT\" -gt \"0\" ]; then\n  echo -e \"{{.RED}}\U0001F6A8 Security Vulnerabilities: $VULN_COUNT ($MIN_SEVERITY and above){{.NC}}\"\n  echo \"$VULNS\" | jq -r '.[] | \"    \\(.cve // \"NO-CVE\"): \\(.pkg) (\\(.sev))\"' | head -10\n  [ \"$VULN_COUNT\" -gt 10 ] && echo \"    ... and $((VULN_COUNT - 10)) more\"\n  echo \"\"\n  echo -e \"{{.YELLOW}}\U0001F4C4 Full report: $SUMMARY_FILE{{.NC}}\"\n  echo -e \"{{.YELLOW}}\U0001F4C4 Filtered data: $LOG_FILE{{.NC}}\"\n  echo -e \"{{.YELLOW}}\U0001F4C4 Raw API response: $RAW_FILE{{.NC}}\"\n  exit 0\nelse\n  echo -e \"{{.GREEN}}✅ No vulnerabilities found ($MIN_SEVERITY severity and above){{.NC}}\"\n  echo \"\"\n  echo \"\U0001F4C4 Report: $SUMMARY_FILE\"\n  echo \"\U0001F4C4 Filtered data: $LOG_FILE\"\n  echo \"\U0001F4C4 Raw API response: $RAW_FILE\"\n  exit 0\nfi\n"
    aliases: [va, vuln]
  # Dependabot alerts list
  cve:list:
    desc: "List all Dependabot alerts with their status"
    silent: true
    deps: [check-gh-cli]
    dotenv: ['.env']
    cmds:
      - "# Set up authentication - prefer gh CLI auth, fallback to GITHUB_TOKEN\nif ! gh auth status &>/dev/null; then\n  # Not authenticated via gh CLI, check for token from .env\n  if [ -n \"${GITHUB_TOKEN}\" ]; then\n    export GH_TOKEN=\"${GITHUB_TOKEN}\"\n  else\n    echo -e \"{{.RED}}GitHub authentication required{{.NC}}\"\n    echo \"Please either:\"\n    echo \"  1. Add GITHUB_TOKEN to your .env file\"\n    echo \"  2. Or authenticate with: gh auth login\"\n    exit 1\n  fi\nfi\n\n# Get repo info\nREPO=$(gh repo view --json nameWithOwner --jq '.nameWithOwner')\necho -e \"{{.CYAN}}Dependabot alerts for: $REPO{{.NC}}\"\necho \"\"\n\n# Get all alerts (open and closed)\nALERTS=$(gh api \"/repos/$REPO/dependabot/alerts\" --paginate 2>/dev/null | jq -s 'add' || echo \"[]\")\n\n# Count by state\nOPEN_COUNT=$(echo \"$ALERTS\" | jq '[.[] | select(.state==\"open\")] | length' 2>/dev/null || echo \"0\")\nDISMISSED_COUNT=$(echo \"$ALERTS\" | jq '[.[] | select(.state==\"dismissed\")] | length' 2>/dev/null || echo \"0\")\nFIXED_COUNT=$(echo \"$ALERTS\" | jq '[.[] | select(.state==\"fixed\")] | length' 2>/dev/null || echo \"0\")\n\necho -e \"{{.GREEN}}Open: $OPEN_COUNT{{.NC}} | {{.YELLOW}}Dismissed: $DISMISSED_COUNT{{.NC}} | {{.CYAN}}Fixed: $FIXED_COUNT{{.NC}}\"\necho \"\"\n\n# Show open alerts\nif [ \"$OPEN_COUNT\" -gt \"0\" ]; then\n  echo -e \"{{.RED}}Open Vulnerabilities:{{.NC}}\"\n  echo \"$ALERTS\" | jq -r '.[] | select(.state==\"open\") | \n    \"  [\\(.security_vulnerability.severity | ascii_upcase)] \\(.security_vulnerability.package.name) - \\(.security_advisory.summary | .[0:80])\"' | head -20\n  [ \"$OPEN_COUNT\" -gt 20 ] && echo \"  ... and $((OPEN_COUNT - 20)) more\"\nfi\n"
    aliases: [vl]
  # List pull requests
  pr:list:
    desc: "List pull requests (use LIMIT=n to change number shown, default 10)"
    silent: true
    deps: [check-gh-cli]
    dotenv: ['.env']
    vars:
      LIMIT: '{{.LIMIT | default "10"}}'
      STATE: '{{.STATE | default "all"}}'
    cmds:
      - "# Set up authentication - prefer gh CLI auth, fallback to GITHUB_TOKEN\nif ! gh auth status &>/dev/null; then\n  # Not authenticated via gh CLI, check for token from .env\n  if [ -n \"${GITHUB_TOKEN}\" ]; then\n    export GH_TOKEN=\"${GITHUB_TOKEN}\"\n  else\n    echo -e \"{{.RED}}GitHub authentication required{{.NC}}\"\n    echo \"Please either:\"\n    echo \"  1. Add GITHUB_TOKEN to your .env file\"\n    echo \"  2. Or authenticate with: gh auth login\"\n    exit 1\n  fi\nfi\n\n# Get repository info\nREPO=$(gh repo view --json nameWithOwner --jq '.nameWithOwner' 2>/dev/null || true)\n\n# If that fails, extract from git remote\nif [ -z \"$REPO\" ]; then\n  REPO=$(git remote get-url origin | sed -E 's|^(https://github.com/\\|git@github.com:)||' | sed 's|\\.git$||')\nfi\n\necho -e \"{{.CYAN}}Pull Requests for: $REPO{{.NC}}\"\necho \"\"\n\n# List PRs with state filter\nSTATE=\"{{.STATE}}\"\nSTATE_FILTER=\"\"\nif [ \"$STATE\" != \"all\" ]; then\n  STATE_FILTER=\"--state $STATE\"\nfi\n\n# Show PRs in a nice table format\ngh pr list $STATE_FILTER --limit {{.LIMIT}} --json number,title,state,author,createdAt,isDraft,headRefName,baseRefName \\\n  --jq '.[] | \n    \"#\\(.number) | \" + \n    (if .isDraft then \"\U0001F4DD \" else \"\" end) + \n    (.title | .[0:60]) + (if (.title | length) > 60 then \"...\" else \"\" end) + \" | \" +\n    (.state | ascii_upcase) + \" | \" +\n    .author.login + \" | \" +\n    (.headRefName + \" → \" + .baseRefName) + \" | \" +\n    (.createdAt | fromdateiso8601 | strftime(\"%Y-%m-%d\"))' | column -t -s '|'\n\necho \"\"\necho -e \"{{.YELLOW}}Total shown: {{.LIMIT}} (use LIMIT=n to change){{.NC}}\"\necho -e \"{{.YELLOW}}State filter: {{.STATE}} (use STATE=open|closed|merged|all){{.NC}}\"\n"
    aliases: [prl]
  # Download PR comments including GHAS security alerts
  pr:comments:
    desc: "Download comments from a pull request (including code review and GHAS alerts)"
    silent: true
    deps: [check-gh-cli]
    vars:
      PR: '{{.PR | default ""}}'
      OUTPUT_DIR: '{{.OUTPUT | default ".github/pr-comments"}}'
    dotenv: ['.env']
    cmds:
      - "# Set up authentication - prefer gh CLI auth, fallback to GITHUB_TOKEN\nif ! gh auth status &>/dev/null; then\n  # Not authenticated via gh CLI, check for token from .env\n  if [ -n \"${GITHUB_TOKEN}\" ]; then\n    export GH_TOKEN=\"${GITHUB_TOKEN}\"\n  else\n    echo -e \"{{.RED}}GitHub authentication required{{.NC}}\"\n    echo \"Please either:\"\n    echo \"  1. Add GITHUB_TOKEN to your .env file\"\n    echo \"  2. Or authenticate with: gh auth login\"\n    exit 1\n  fi\nfi\n\n# Get repository info\n# First try gh CLI\nREPO=$(gh repo view --json nameWithOwner --jq '.nameWithOwner' 2>/dev/null || true)\n\n# If that fails, extract from git remote\nif [ -z \"$REPO\" ]; then\n  REPO=$(git remote get-url origin | sed -E 's|^(https://github.com/\\|git@github.com:)||' | sed 's|\\.git$||')\nfi\n\necho -e \"{{.CYAN}}Repository: $REPO{{.NC}}\"\n\n# Handle PR selection\nPR_NUMBER=\"{{.PR}}\"\n\n# If no PR specified, show list and prompt\nif [ -z \"$PR_NUMBER\" ]; then\n  echo -e \"{{.CYAN}}Fetching pull requests...{{.NC}}\"\n  echo \"\"\n  \n  # List recent PRs\n  gh pr list --limit 10 --json number,title,state,author,createdAt --jq '.[] | \"#\\(.number) | \\(.title) | \\(.state) | \\(.author.login)\"' | column -t -s '|'\n  \n  echo \"\"\n  read -p \"Enter PR number (or 'latest' for most recent): \" PR_NUMBER\nfi\n\n# Handle \"latest\" keyword\nif [ \"$PR_NUMBER\" = \"latest\" ] || [ -z \"$PR_NUMBER\" ]; then\n  PR_NUMBER=$(gh pr list --limit 1 --json number --jq '.[0].number')\n  if [ -z \"$PR_NUMBER\" ]; then\n    echo -e \"{{.RED}}No pull requests found{{.NC}}\"\n    exit 1\n  fi\n  echo -e \"{{.CYAN}}Using latest PR: #$PR_NUMBER{{.NC}}\"\nfi\n\n# Create output directory\nmkdir -p \"{{.OUTPUT_DIR}}\"\n\n# Get PR details\necho -e \"{{.CYAN}}Fetching PR #$PR_NUMBER details...{{.NC}}\"\nPR_DATA=$(gh pr view \"$PR_NUMBER\" --json number,title,author,state,body,createdAt,url,headRefName,baseRefName)\n\n# Save PR metadata\necho \"$PR_DATA\" | jq '.' > \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-metadata.json\"\n\n# Extract PR info for report\nPR_TITLE=$(echo \"$PR_DATA\" | jq -r '.title')\nPR_AUTHOR=$(echo \"$PR_DATA\" | jq -r '.author.login')\nPR_STATE=$(echo \"$PR_DATA\" | jq -r '.state')\nPR_BRANCH=$(echo \"$PR_DATA\" | jq -r '.headRefName')\nPR_BASE=$(echo \"$PR_DATA\" | jq -r '.baseRefName')\nPR_URL=$(echo \"$PR_DATA\" | jq -r '.url')\n\n# Get all comments (issue comments, review comments, and reviews)\necho -e \"{{.CYAN}}Fetching comments...{{.NC}}\"\n\n# 1. Issue comments (general PR comments)\nISSUE_COMMENTS=$(gh api \"/repos/$REPO/issues/$PR_NUMBER/comments\" --paginate | jq -s 'add // []')\necho \"$ISSUE_COMMENTS\" > \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-issue-comments.json\"\n\n# 2. Review comments (inline code comments)\nREVIEW_COMMENTS=$(gh api \"/repos/$REPO/pulls/$PR_NUMBER/comments\" --paginate | jq -s 'add // []')\necho \"$REVIEW_COMMENTS\" > \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-review-comments.json\"\n\n# 3. PR reviews (approve/request changes/comment)\nREVIEWS=$(gh api \"/repos/$REPO/pulls/$PR_NUMBER/reviews\" --paginate | jq -s 'add // []')\necho \"$REVIEWS\" > \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-reviews.json\"\n\n# 4. Check runs (including GHAS/CodeQL)\necho -e \"{{.CYAN}}Fetching security alerts and check runs...{{.NC}}\"\nCHECK_RUNS=$(gh api \"/repos/$REPO/commits/$(gh pr view $PR_NUMBER --json headRefOid --jq '.headRefOid')/check-runs\" --paginate | jq -s 'add // []' | jq '.check_runs // []')\necho \"$CHECK_RUNS\" > \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-check-runs.json\"\n\n# Generate consolidated report\necho -e \"{{.CYAN}}Generating report...{{.NC}}\"\n\n# Create report using echo commands to avoid YAML parsing issues\n{\n  echo \"# Pull Request Comments Report\"\n  echo \"\"\n  echo \"**PR:** #$PR_NUMBER - $PR_TITLE\"\n  echo \"**Author:** $PR_AUTHOR\"\n  echo \"**State:** $PR_STATE\"\n  echo \"**Branch:** $PR_BRANCH → $PR_BASE\"\n  echo \"**URL:** $PR_URL\"\n  echo \"**Generated:** $(date)\"\n  echo \"\"\n  echo \"## Summary\"\n  echo \"\"\n  echo \"- Issue Comments: $(echo \"$ISSUE_COMMENTS\" | jq 'length')\"\n  echo \"- Review Comments: $(echo \"$REVIEW_COMMENTS\" | jq 'length')\"\n  echo \"- Reviews: $(echo \"$REVIEWS\" | jq 'length')\"\n  echo \"- Check Runs: $(echo \"$CHECK_RUNS\" | jq 'length')\"\n  echo \"\"\n  echo \"## Security Alerts (GHAS/CodeQL)\"\n  echo \"\"\n} > \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\n\n# Extract GHAS/CodeQL findings from check runs\nSECURITY_CHECKS=$(echo \"$CHECK_RUNS\" | jq -r '.[] | select(((.app.slug // \"\") == \"github-code-scanning\") or ((.name // \"\") | contains(\"CodeQL\")) or ((.name // \"\") | contains(\"Security\")))')\n\nif [ -n \"$SECURITY_CHECKS\" ]; then\n  echo \"$SECURITY_CHECKS\" | jq -r '. | \"### \\(.name)\\n**Status:** \\(.status) - \\(.conclusion // \"in progress\")\\n**Details:** \\(.output.summary // \"No summary available\")\\n\"' >> \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\nelse\n  echo \"*No security alerts found*\" >> \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\nfi\n\necho \"\" >> \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\necho \"## Reviews\" >> \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\necho \"\" >> \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\n\n# Add reviews to report\nif [ $(echo \"$REVIEWS\" | jq 'length') -gt 0 ]; then\n  echo \"$REVIEWS\" | jq -r '.[] | \"### \\(.user.login) - \\(.state)\\n**Submitted:** \\(.submitted_at)\\n\\(.body // \"*No comment*\")\\n\"' >> \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\nelse\n  echo \"*No reviews yet*\" >> \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\nfi\n\necho \"\" >> \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\necho \"## Code Review Comments\" >> \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\necho \"\" >> \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\n\n# Add review comments (inline)\nif [ $(echo \"$REVIEW_COMMENTS\" | jq 'length') -gt 0 ]; then\n  echo \"$REVIEW_COMMENTS\" | jq -r '.[] | \"### \\(.user.login) on \\(.path):\\(.line // .original_line // \"\")\\n\\(.body)\\n**Created:** \\(.created_at)\\n\"' >> \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\nelse\n  echo \"*No code review comments*\" >> \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\nfi\n\necho \"\" >> \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\necho \"## General Comments\" >> \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\necho \"\" >> \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\n\n# Add issue comments\nif [ $(echo \"$ISSUE_COMMENTS\" | jq 'length') -gt 0 ]; then\n  echo \"$ISSUE_COMMENTS\" | jq -r '.[] | \"### \\(.user.login)\\n\\(.body)\\n**Created:** \\(.created_at)\\n\"' >> \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\nelse\n  echo \"*No general comments*\" >> \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\nfi\n\n\n# Count totals\nTOTAL_ISSUE_COMMENTS=$(echo \"$ISSUE_COMMENTS\" | jq 'length')\nTOTAL_REVIEW_COMMENTS=$(echo \"$REVIEW_COMMENTS\" | jq 'length')\nTOTAL_REVIEWS=$(echo \"$REVIEWS\" | jq 'length')\nTOTAL_SECURITY=$(echo \"$CHECK_RUNS\" | jq '[.[] | select(((.app.slug // \"\") == \"github-code-scanning\") or ((.name // \"\") | contains(\"CodeQL\")) or ((.name // \"\") | contains(\"Security\")))] | length')\n\necho \"\"\necho -e \"{{.GREEN}}✅ PR #$PR_NUMBER comments downloaded{{.NC}}\"\necho \"\"\necho \"\U0001F4CA Summary:\"\necho \"  - General comments: $TOTAL_ISSUE_COMMENTS\"\necho \"  - Code review comments: $TOTAL_REVIEW_COMMENTS\"\necho \"  - Reviews: $TOTAL_REVIEWS\"\necho \"  - Security checks: $TOTAL_SECURITY\"\necho \"\"\necho \"\U0001F4C1 Files saved to: {{.OUTPUT_DIR}}/\"\necho \"  - pr-$PR_NUMBER-metadata.json\"\necho \"  - pr-$PR_NUMBER-issue-comments.json\"\necho \"  - pr-$PR_NUMBER-review-comments.json\"\necho \"  - pr-$PR_NUMBER-reviews.json\"\necho \"  - pr-$PR_NUMBER-check-runs.json\"\necho \"  - pr-$PR_NUMBER-report.md\"\necho \"\"\necho \"\U0001F4C4 Opening report...\"\n\n# Try to open the report\nif command -v code &> /dev/null; then\n  code \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\nelif command -v open &> /dev/null; then\n  open \"{{.OUTPUT_DIR}}/pr-$PR_NUMBER-report.md\"\nfi\n"
    aliases: [prc]
