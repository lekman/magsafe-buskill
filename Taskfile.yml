version: "3"

vars:
  HOOKS_PATH: .githooks
  SEMGREP_CONFIG: auto

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list

  init:
    desc: Initialize development environment
    cmds:
      - task: check-tools
      - task: setup-hooks
      - task: setup-sbom
      - task: verify-setup
    silent: true

  check-tools:
    desc: Check required development tools
    cmds:
      - |
        echo "üîç Checking development tools..."
        missing_tools=0

        # Check for git
        if ! command -v git &> /dev/null; then
          echo "‚ùå git is not installed"
          missing_tools=$((missing_tools + 1))
        else
          echo "‚úÖ git $(git --version | awk '{print $3}')"
        fi

        # Check for Swift
        if ! command -v swift &> /dev/null; then
          echo "‚ùå Swift is not installed"
          missing_tools=$((missing_tools + 1))
        else
          echo "‚úÖ Swift $(swift --version | head -1 | awk '{print $4}')"
        fi

        # Check for Semgrep (optional)
        if ! command -v semgrep &> /dev/null; then
          echo "‚ö†Ô∏è  Semgrep not installed (optional but recommended)"
          echo "   Install with: brew install semgrep"
        else
          echo "‚úÖ Semgrep $(semgrep --version | head -1)"
        fi

        if [ $missing_tools -gt 0 ]; then
          exit 1
        fi
    silent: true

  setup-sbom:
    desc: Setup SBOM generation dependencies
    cmds:
      - |
        echo "üîç Checking SBOM dependencies..."
        if ! command -v jq &> /dev/null; then
          echo "‚ö†Ô∏è  jq not installed (required for SBOM generation)"
          echo "   Install with: brew install jq"
        else
          echo "‚úÖ jq $(jq --version)"
        fi

        if ! command -v uuidgen &> /dev/null; then
          echo "‚ö†Ô∏è  uuidgen not found (should be built-in on macOS)"
        else
          echo "‚úÖ uuidgen available"
        fi

        echo "‚úÖ SBOM generation ready (using Swift Package Manager)"
    silent: true

  setup-hooks:
    desc: Configure git hooks for MagSafe Guard development
    vars:
      CURRENT_HOOKS_PATH:
        sh: git config core.hooksPath || echo ""
    status:
      - test "{{.CURRENT_HOOKS_PATH}}" = "{{.HOOKS_PATH}}"
    cmds:
      - |
        echo "üîß Setting up MagSafe Guard development environment..."

        # Configure git to use our hooks directory
        git config core.hooksPath {{.HOOKS_PATH}}
        chmod +x {{.HOOKS_PATH}}/* 2>/dev/null || true

        echo "‚úÖ Git hooks configured"

        # Check if Semgrep is installed
        if command -v semgrep &> /dev/null; then
          echo "‚úÖ Semgrep is installed (version: $(semgrep --version | head -1))"
        else
          echo "‚ÑπÔ∏è  Semgrep not installed (optional but recommended)"
          echo "   To install: brew install semgrep"
          echo "   Pre-commit will still run basic security checks"
        fi

        echo ""
        echo "Git hooks will now:"
        echo "  ‚Ä¢ Check for hardcoded secrets in Swift files"
        echo "  ‚Ä¢ Detect private key files"
        echo "  ‚Ä¢ Prevent committing .env files"
        echo "  ‚Ä¢ Run Semgrep scan (if installed)"
        echo "  ‚Ä¢ Validate commit message format (Conventional Commits)"
        echo "  ‚Ä¢ Block certain words in commit messages"
        echo ""
        echo "To bypass hooks in emergencies: git commit --no-verify"
        echo "To skip Semgrep only: SKIP_SEMGREP=1 git commit"
    silent: true

  verify-setup:
    desc: Verify development setup
    cmds:
      - |
        echo ""
        echo "üéâ Development environment ready!"
        echo ""
        echo "Git hooks installed:"
        hooks_path=$(git config core.hooksPath)
        if [ -n "$hooks_path" ]; then
          echo "  ‚Ä¢ Pre-commit: Security scanning"
          echo "  ‚Ä¢ Commit-msg: Conventional commits validation"
        fi
        echo ""
        echo "Next steps:"
        echo "  1. Make changes to the code"
        echo "  2. Commit with conventional format: git commit -m 'feat: description'"
        echo "  3. Run 'task test' before pushing"
    silent: true

  test:
    desc: Run all tests
    cmds:
      - task: test:security
      - task: test:swift
      - echo "‚úÖ All tests passed!"

  test:security:
    desc: Run security checks locally
    silent: true
    cmds:
      - |
        echo "üîí Running security checks..."

        # Basic secret scanning
        if find . -name "*.swift" -type f -exec grep -l -E "password\s*=\s*\"[^\"]+\"" {} \; 2>/dev/null | head -1 | grep -q .; then
          echo "‚ùå Found hardcoded passwords"
          exit 1
        fi

        # Check for private keys
        if find . -type f \( -name "*.pem" -o -name "*.key" \) -not -path "./.git/*" | head -1 | grep -q .; then
          echo "‚ùå Found private key files"
          exit 1
        fi

        echo "‚úÖ Basic security checks passed"

        # Run Semgrep if available
        if command -v semgrep &> /dev/null; then
          echo "Running Semgrep scan..."
          semgrep --config={{.SEMGREP_CONFIG}} --error --quiet . || exit 1
          echo "‚úÖ Semgrep scan passed"
        fi

  test:swift:
    desc: Run Swift tests
    silent: true
    cmds:
      - |
        echo "üß™ Running Swift tests..."
        swift test

  test:ci:
    desc: Run tests (same as test, kept for compatibility)
    cmds:
      - task: test

  test:coverage:
    desc: Run tests with coverage and ensure >80%
    cmds:
      - echo "Running tests with coverage..."
      - swift test --enable-code-coverage
      - |
        echo "Generating coverage report..."
        PROF_DATA=$(find .build -name 'default.profdata' -type f | head -1)
        EXECUTABLE=$(find .build -name 'MagSafeGuardPackageTests.xctest' -type d | head -1)/Contents/MacOS/MagSafeGuardPackageTests

        if [[ -f "$PROF_DATA" && -f "$EXECUTABLE" ]]; then
          # Generate detailed coverage report
          xcrun llvm-cov report "$EXECUTABLE" \
            -instr-profile="$PROF_DATA" \
            -ignore-filename-regex=".*Tests\.swift|.*Mock.*\.swift|.*/runner.swift|.*/MagSafeGuardApp\.swift|.*/PowerMonitorService\.swift|.*/PowerMonitorCore\.swift|.*LAContext\.swift|.*/MacSystemActions\.swift|.*Protocol\.swift" | tee coverage-report.txt
          
          # Extract total coverage percentage (line coverage is in column 10)
          COVERAGE=$(tail -1 coverage-report.txt | awk '{print $10}' | sed 's/%//')
          
          echo ""
          echo "Total coverage: ${COVERAGE}%"
          
          # Check if coverage meets threshold
          if (( $(echo "$COVERAGE < 80" | bc -l) )); then
            echo "‚ùå Coverage is below 80% threshold!"
            echo ""
            echo "To improve coverage, add tests for:"
            grep -E "^\S+\.swift" coverage-report.txt | grep -v "100.00%" | head -10
            rm coverage-report.txt
            exit 1
          else
            echo "‚úÖ Coverage meets 80% threshold!"
            rm coverage-report.txt
          fi
        else
          echo "‚ùå Error: Could not find coverage data files"
          exit 1
        fi

  test:coverage:html:
    desc: Generate HTML coverage report
    cmds:
      - swift test --enable-code-coverage
      - |
        PROF_DATA=$(find .build -name 'default.profdata' -type f | head -1)
        EXECUTABLE=$(find .build -name 'MagSafeGuardPackageTests.xctest' -type d | head -1)/Contents/MacOS/MagSafeGuardPackageTests

        if [[ -f "$PROF_DATA" && -f "$EXECUTABLE" ]]; then
          xcrun llvm-cov show "$EXECUTABLE" \
            -instr-profile="$PROF_DATA" \
            -format=html \
            -output-dir=coverage-html \
            -ignore-filename-regex=".*Tests\.swift|.*Mock.*\.swift|.*/MagSafeGuardApp\.swift|.*/PowerMonitorService\.swift|.*/PowerMonitorCore\.swift|.*LAContext\.swift|.*/MacSystemActions\.swift|.*Protocol\.swift"
          echo "Coverage report generated at: coverage-html/index.html"
          open coverage-html/index.html
        fi

  lint:
    desc: Run linters
    cmds:
      - task: lint:swift
      - task: lint:markdown

  lint:swift:
    desc: Lint Swift files
    silent: true
    cmds:
      - |
        echo "üîç Linting Swift files..."
        if command -v swiftlint &> /dev/null; then
          swiftlint lint --quiet
        else
          echo "‚ö†Ô∏è  SwiftLint not installed"
          echo "   Install with: brew install swiftlint"
        fi

  lint:markdown:
    desc: Lint Markdown files
    silent: true
    cmds:
      - |
        echo "üîç Linting Markdown files..."

        # Check if markdownlint is installed
        if ! command -v markdownlint &> /dev/null; then
          echo "üì¶ markdownlint not found. Installing..."
          
          # Try to install with npm first (most universal)
          if command -v npm &> /dev/null; then
            echo "Installing with npm..."
            npm install -g markdownlint-cli
          # Try Homebrew as fallback
          elif command -v brew &> /dev/null; then
            echo "Installing with Homebrew..."
            brew install markdownlint-cli
          else
            echo "‚ö†Ô∏è  Cannot auto-install markdownlint"
            echo "   Please install Node.js or Homebrew first"
            exit 1
          fi
        fi

        # Run the linter
        markdownlint '**/*.md' --ignore node_modules

  lint:fix:
    desc: Fix linting issues automatically
    cmds:
      - task: lint:fix:markdown
      - echo "‚úÖ Linting fixes complete!"

  lint:fix:markdown:
    desc: Fix Markdown formatting issues
    silent: true
    cmds:
      - |
        echo "üîß Fixing Markdown formatting issues..."

        # Check if markdownlint is installed
        if ! command -v markdownlint &> /dev/null; then
          echo "üì¶ markdownlint not found. Installing..."
          
          # Try to install with npm first (most universal)
          if command -v npm &> /dev/null; then
            echo "Installing with npm..."
            npm install -g markdownlint-cli
          # Try Homebrew as fallback
          elif command -v brew &> /dev/null; then
            echo "Installing with Homebrew..."
            brew install markdownlint-cli
          else
            echo "‚ùå Neither npm nor Homebrew found"
            echo ""
            echo "Please install Node.js or Homebrew first:"
            echo "  - Node.js: https://nodejs.org/"
            echo "  - Homebrew: https://brew.sh/"
            exit 1
          fi
          
          # Verify installation
          if ! command -v markdownlint &> /dev/null; then
            echo "‚ùå Installation failed"
            exit 1
          fi
          echo "‚úÖ markdownlint installed successfully"
        fi

        # Fix all markdown files
        echo "Running markdown formatter..."
        markdownlint '**/*.md' --ignore node_modules --fix
        echo "‚úÖ Markdown files formatted"

        # Show which files were modified
        echo ""
        echo "Modified files:"
        git diff --name-only | grep '\.md$' || echo "  No changes needed"

  clean:
    desc: Clean build artifacts
    silent: true
    cmds:
      - |
        echo "üßπ Cleaning build artifacts..."
        rm -rf .build/
        rm -rf *.xcodeproj
        rm -rf coverage-html/
        rm -f coverage-report.txt
        rm -f coverage.lcov
        echo "‚úÖ Clean complete"

  run:
    desc: Build and run MagSafe Guard as a menu bar app
    silent: true
    cmds:
      - |
        echo "üî® Building MagSafe Guard..."

        # Build in release mode for better performance
        swift build -c release

        # Find the built executable
        EXECUTABLE_PATH=".build/release/MagSafeGuard"

        if [ ! -f "$EXECUTABLE_PATH" ]; then
          echo "‚ùå Build failed or executable not found"
          exit 1
        fi

        echo "‚úÖ Build complete"

        # Create a minimal app bundle structure
        APP_NAME="MagSafeGuard.app"
        APP_PATH="/tmp/$APP_NAME"
        CONTENTS_PATH="$APP_PATH/Contents"
        MACOS_PATH="$CONTENTS_PATH/MacOS"

        echo "üì¶ Creating app bundle..."

        # Remove old app if exists
        rm -rf "$APP_PATH"

        # Create directory structure
        mkdir -p "$MACOS_PATH"

        # Copy executable
        cp "$EXECUTABLE_PATH" "$MACOS_PATH/MagSafeGuard"

        # Create Info.plist
        cat > "$CONTENTS_PATH/Info.plist" <<EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>CFBundleExecutable</key>
            <string>MagSafeGuard</string>
            <key>CFBundleIdentifier</key>
            <string>com.lekman.MagSafeGuard</string>
            <key>CFBundleName</key>
            <string>MagSafe Guard</string>
            <key>CFBundleShortVersionString</key>
            <string>1.0</string>
            <key>CFBundleVersion</key>
            <string>1</string>
            <key>LSMinimumSystemVersion</key>
            <string>13.0</string>
            <key>LSUIElement</key>
            <true/>
            <key>NSHighResolutionCapable</key>
            <true/>
        </dict>
        </plist>
        EOF

        echo "‚úÖ App bundle created at: $APP_PATH"
        echo "üöÄ Launching MagSafe Guard..."
        echo ""
        echo "‚ÑπÔ∏è  The app will run in the menu bar (top right of your screen)"
        echo "‚ÑπÔ∏è  Look for 'MG' text or a shield icon"
        echo ""

        # Launch the app
        open "$APP_PATH"

        echo ""
        echo "‚úÖ MagSafe Guard is now running in your menu bar!"
        echo ""
        echo "üí° Tips:"
        echo "   - Look for 'MG' text or shield icon in the menu bar"
        echo "   - Click the icon to see the menu"
        echo "   - Select 'Arm' to enable protection"
        echo "   - Select 'Show Demo...' to test power monitoring"
        echo ""
        echo "To stop the app: Click the menu bar icon and select 'Quit MagSafe Guard'"

  run:debug:
    desc: Build and run MagSafe Guard in debug mode
    cmds:
      - |
        echo "üî® Building MagSafe Guard (debug mode)..."

        # Build in debug mode
        swift build

        # Find the built executable
        EXECUTABLE_PATH=".build/debug/MagSafeGuard"

        if [ ! -f "$EXECUTABLE_PATH" ]; then
          echo "‚ùå Build failed or executable not found"
          exit 1
        fi

        echo "‚úÖ Build complete"

        # Create a minimal app bundle structure
        APP_NAME="MagSafeGuard-Debug.app"
        APP_PATH="/tmp/$APP_NAME"
        CONTENTS_PATH="$APP_PATH/Contents"
        MACOS_PATH="$CONTENTS_PATH/MacOS"

        echo "üì¶ Creating debug app bundle..."

        # Remove old app if exists
        rm -rf "$APP_PATH"

        # Create directory structure
        mkdir -p "$MACOS_PATH"

        # Copy executable
        cp "$EXECUTABLE_PATH" "$MACOS_PATH/MagSafeGuard"

        # Create Info.plist
        cat > "$CONTENTS_PATH/Info.plist" <<EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>CFBundleExecutable</key>
            <string>MagSafeGuard</string>
            <key>CFBundleIdentifier</key>
            <string>com.lekman.MagSafeGuard.debug</string>
            <key>CFBundleName</key>
            <string>MagSafe Guard (Debug)</string>
            <key>CFBundleShortVersionString</key>
            <string>1.0</string>
            <key>CFBundleVersion</key>
            <string>1</string>
            <key>LSMinimumSystemVersion</key>
            <string>13.0</string>
            <key>LSUIElement</key>
            <true/>
            <key>NSHighResolutionCapable</key>
            <true/>
        </dict>
        </plist>
        EOF

        echo "‚úÖ Debug app bundle created"
        echo "üöÄ Launching MagSafe Guard (Debug)..."

        # Launch the app
        open "$APP_PATH"

        echo ""
        echo "‚úÖ Running in debug mode - check console for debug output"

  dev:setup:
    desc: Complete development setup (hooks + tools)
    silent: true
    cmds:
      - task: init
      - |
        echo ""
        echo "üì¶ Installing recommended tools..."

        # Check if Homebrew is installed
        if command -v brew &> /dev/null; then
          echo "Installing/updating tools via Homebrew..."
          
          # Install Semgrep
          if ! command -v semgrep &> /dev/null; then
            brew install semgrep
          fi
          
          # Install SwiftLint
          if ! command -v swiftlint &> /dev/null; then
            brew install swiftlint
          fi
          
          # Install markdownlint
          if ! command -v markdownlint &> /dev/null; then
            brew install markdownlint-cli
          fi
          
          echo "‚úÖ Development tools installed"
        else
          echo "‚ö†Ô∏è  Homebrew not found. Install tools manually:"
          echo "   - Semgrep: https://semgrep.dev/docs/getting-started/"
          echo "   - SwiftLint: https://github.com/realm/SwiftLint"
          echo "   - markdownlint: npm install -g markdownlint-cli"
        fi

  pr:fix:
    desc: Fix PR documentation formatting
    silent: true
    cmds:
      - |
        echo "üìù Fixing PR documentation..."
        pr_file=$(find . -name "pr.*.md" | head -1)
        if [ -n "$pr_file" ]; then
          echo "Found PR file: $pr_file"
          markdownlint "$pr_file" --fix
          echo "‚úÖ PR documentation fixed"
        else
          echo "No PR documentation found (pr.*.md)"
        fi

  pre-push:
    desc: Run all checks before pushing
    cmds:
      - echo "üöÄ Running pre-push checks..."
      - task: lint:fix:markdown
      - task: test:coverage
      - task: test:security
      - task: lint
      - task: sbom
      - task: docs:update
      - echo "‚úÖ All pre-push checks passed!"
      - echo "Ready to push your changes."

  pre-pr:
    desc: Run all checks before creating a PR
    cmds:
      - echo "üöÄ Running pre-PR checks..."
      - task: lint:fix:markdown
      - task: test:coverage
      - task: test:security
      - task: lint
      - echo "‚úÖ All pre-PR checks passed!"
      - echo "Ready to create your PR."

  commit:
    desc: Interactive commit with conventional format
    cmds:
      - |
        echo "üìù Creating conventional commit..."
        echo ""
        echo "Select commit type:"
        echo "  1) feat     - New feature"
        echo "  2) fix      - Bug fix"
        echo "  3) docs     - Documentation"
        echo "  4) style    - Code style"
        echo "  5) refactor - Code refactoring"
        echo "  6) test     - Tests"
        echo "  7) chore    - Maintenance"
        echo ""
        read -p "Enter number (1-7): " type_num

        case $type_num in
          1) type="feat";;
          2) type="fix";;
          3) type="docs";;
          4) type="style";;
          5) type="refactor";;
          6) type="test";;
          7) type="chore";;
          *) echo "Invalid selection"; exit 1;;
        esac

        read -p "Enter scope (optional, press enter to skip): " scope
        read -p "Enter commit message: " message

        if [ -n "$scope" ]; then
          commit_msg="${type}(${scope}): ${message}"
        else
          commit_msg="${type}: ${message}"
        fi

        echo ""
        echo "Commit message: $commit_msg"
        read -p "Proceed? (y/n): " confirm

        if [ "$confirm" = "y" ]; then
          git commit -m "$commit_msg"
        else
          echo "Commit cancelled"
        fi
    interactive: true

  test:convert:
    desc: Convert Swift coverage to SonarQube generic XML format
    silent: true
    cmds:
      - |
        echo "üîÑ Converting Swift coverage to SonarQube format..."

        # First, run tests with coverage if needed
        if [ ! -d ".build" ] || [ -z "$(find .build -name 'default.profdata' -type f 2>/dev/null)" ]; then
          echo "üß™ Running tests with coverage..."
          swift test --enable-code-coverage
        fi

        # Find the coverage data
        PROF_DATA=$(find .build -name 'default.profdata' -type f | head -1)
        EXECUTABLE=$(find .build -name 'MagSafeGuardPackageTests.xctest' -type d | head -1)/Contents/MacOS/MagSafeGuardPackageTests

        if [[ -f "$PROF_DATA" && -f "$EXECUTABLE" ]]; then
          echo "üìä Generating SonarQube generic coverage XML..."
          
          # Function to convert xcov output to generic XML format
          convert_to_xml() {
            echo '<coverage version="1">'
            xcrun llvm-cov show "$EXECUTABLE" \
              -instr-profile="$PROF_DATA" \
              -use-color=false \
              -ignore-filename-regex=".*Tests\.swift|.*Mocks?\.swift|.*/MagSafeGuardApp\.swift|.*/PowerMonitorService\.swift|.*/PowerMonitorCore\.swift|.*LAContext\.swift|.*/MacSystemActions\.swift|.*Protocol\.swift" | \
            awk '
              /^[[:space:]]*[^[:space:]]+:$/ {
                if (in_file) print "  </file>"
                gsub(/:$/, "", $1)
                gsub(/&/, "\\&amp;", $1)
                print "  <file path=\"" $1 "\">"
                in_file = 1
                next
              }
              /^[[:space:]]*[0-9]+\|/ {
                split($0, parts, "|")
                linenum = parts[1]
                gsub(/^[[:space:]]+/, "", linenum)
                gsub(/[[:space:]]+$/, "", linenum)
                
                # Check if line is covered (has execution count)
                if (match(parts[2], /^[[:space:]]*[0-9]+/)) {
                  print "    <lineToCover lineNumber=\"" linenum "\" covered=\"true\"/>"
                } else if (match(parts[2], /^[[:space:]]*0/)) {
                  print "    <lineToCover lineNumber=\"" linenum "\" covered=\"false\"/>"
                }
              }
              END {
                if (in_file) print "  </file>"
              }
            '
            echo '</coverage>'
          }
          
          # Generate the coverage XML
          convert_to_xml > coverage.xml
          
          if [ -f "coverage.xml" ] && [ -s "coverage.xml" ]; then
            echo "‚úÖ Successfully generated coverage.xml"
            echo "   File size: $(wc -c < coverage.xml) bytes"
            echo "   Files covered: $(grep -c '<file path=' coverage.xml || echo 0)"
          else
            echo "‚ùå Failed to create coverage.xml or file is empty"
            exit 1
          fi
        else
          echo "‚ùå Coverage data not found"
          echo "PROF_DATA: $PROF_DATA"
          echo "EXECUTABLE: $EXECUTABLE"
          exit 1
        fi

  sbom:
    desc: Generate Software Bill of Materials (SBOM) in SPDX format
    silent: true
    cmds:
      - |
        echo "üì¶ Generating SBOM for Swift project..."

        # Get package info
        PACKAGE_NAME=$(swift package dump-package | jq -r '.name')
        VERSION=$(git describe --tags --always 2>/dev/null || echo "1.0.0")
        TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

        # Create SPDX SBOM
        echo "SPDXVersion: SPDX-2.3" > sbom.spdx
        echo "DataLicense: CC0-1.0" >> sbom.spdx
        echo "SPDXID: SPDXRef-DOCUMENT" >> sbom.spdx
        echo "DocumentName: ${PACKAGE_NAME}" >> sbom.spdx
        echo "DocumentNamespace: https://github.com/lekman/magsafe-buskill/spdx-${VERSION}-$(date +%s)" >> sbom.spdx
        echo "Creator: Tool: swift-package-sbom-1.0.0" >> sbom.spdx
        echo "Created: ${TIMESTAMP}" >> sbom.spdx
        echo "" >> sbom.spdx

        # Package information
        echo "PackageName: ${PACKAGE_NAME}" >> sbom.spdx
        echo "SPDXID: SPDXRef-Package-${PACKAGE_NAME}" >> sbom.spdx
        echo "PackageVersion: ${VERSION}" >> sbom.spdx
        echo "PackageDownloadLocation: https://github.com/lekman/magsafe-buskill" >> sbom.spdx
        echo "FilesAnalyzed: false" >> sbom.spdx
        echo "PackageLicenseConcluded: MIT" >> sbom.spdx
        echo "PackageLicenseDeclared: MIT" >> sbom.spdx
        echo "PackageCopyrightText: Copyright (c) 2025 Tobias Lekman" >> sbom.spdx
        echo "" >> sbom.spdx

        # Relationship
        echo "Relationship: SPDXRef-DOCUMENT DESCRIBES SPDXRef-Package-${PACKAGE_NAME}" >> sbom.spdx

        # Process dependencies
        echo "" >> sbom.spdx
        echo "# Dependencies" >> sbom.spdx
        DEPS=$(swift package show-dependencies --format json | jq -r '.dependencies[]? | "PackageName: " + .name + "\nSPDXID: SPDXRef-Package-" + .identity + "\nPackageVersion: " + (.version // "unknown") + "\nPackageDownloadLocation: " + (.url // "NOASSERTION") + "\nFilesAnalyzed: false\nPackageLicenseConcluded: NOASSERTION\nPackageLicenseDeclared: NOASSERTION\nPackageCopyrightText: NOASSERTION\n\nRelationship: SPDXRef-Package-" + .identity + " DEPENDENCY_OF SPDXRef-Package-${PACKAGE_NAME}\n"' 2>/dev/null || echo "")

        if [ -n "$DEPS" ]; then
          echo "$DEPS" >> sbom.spdx
        fi

        echo "‚úÖ SBOM generated: sbom.spdx"
        echo "   Format: SPDX 2.3"
        echo "   Project: ${PACKAGE_NAME} v${VERSION}"

        # Also generate in JSON format
        swift package show-dependencies --format json > sbom-deps.json

        echo "‚úÖ Also generated: sbom-deps.json (Swift dependencies)"
    sources:
      - Package.swift
      - Sources/**/*.swift
    generates:
      - sbom.spdx
      - sbom-deps.json

  sbom:install:
    desc: Install SBOM generation dependencies
    silent: true
    cmds:
      - |
        echo "üì¶ Installing SBOM dependencies..."

        # Check if Homebrew is installed
        if ! command -v brew &> /dev/null; then
          echo "‚ùå Homebrew is not installed"
          echo "   Install from: https://brew.sh"
          exit 1
        fi

        # Install jq if not present
        if ! command -v jq &> /dev/null; then
          echo "Installing jq..."
          brew install jq
        else
          echo "‚úÖ jq already installed"
        fi

        echo "‚úÖ SBOM dependencies installed"
        echo "   You can now run: task sbom"

  docs:update:
    desc: Update TaskMaster progress to main README
    silent: true
    cmds:
      - |
        task-master sync-readme >/dev/null 2>&1

  # Security Tasks
  security:
    desc: Run all security checks and fixes
    cmds:
      - task: security:check-pins
      - task: security:scan-secrets
      - echo "‚úÖ All security checks passed!"

  security:fix:
    desc: Fix all security issues automatically
    cmds:
      - task: security:pin-actions
      - task: security:dependabot
      - echo "‚úÖ Security fixes applied!"

  security:pin-actions:
    desc: Pin all GitHub Actions to specific commit SHAs for security
    silent: false
    cmds:
      - |
        # Check if jq is installed (required for the script)
        if ! command -v jq &> /dev/null; then
          echo "üì¶ Installing jq (required for pinning actions)..."
          if command -v brew &> /dev/null; then
            brew install jq
          else
            echo "‚ùå jq is required but Homebrew is not available"
            echo "   Please install jq manually: https://jqlang.github.io/jq/download/"
            exit 1
          fi
        fi
        
        # Run the automated pinning script
        ./scripts/pin-github-actions.sh

  security:update-pins:
    desc: Update GitHub Action pins to latest SHAs for pinned versions
    silent: false
    cmds:
      - |
        # Check if jq is installed (required for the script)
        if ! command -v jq &> /dev/null; then
          echo "üì¶ Installing jq (required for updating pins)..."
          if command -v brew &> /dev/null; then
            brew install jq
          else
            echo "‚ùå jq is required but Homebrew is not available"
            echo "   Please install jq manually: https://jqlang.github.io/jq/download/"
            exit 1
          fi
        fi
        
        # Run the update script
        ./scripts/update-action-pins.sh

  security:dependabot:
    desc: Set up Dependabot to keep GitHub Actions updated
    silent: false
    cmds:
      - |
        echo "ü§ñ Setting up Dependabot for GitHub Actions..."
        
        mkdir -p .github
        
        cat > .github/dependabot.yml << 'EOF'
        version: 2
        updates:
          # Maintain dependencies for GitHub Actions
          - package-ecosystem: "github-actions"
            directory: "/"
            schedule:
              interval: "weekly"
              day: "monday"
              time: "10:00"
            reviewers:
              - "@lekman"
            labels:
              - "dependencies"
              - "github-actions"
            commit-message:
              prefix: "chore"
              prefix-development: "chore"
              include: "scope"
            open-pull-requests-limit: 10
            # Group all action updates into a single PR
            groups:
              github-actions:
                patterns:
                  - "*"
        
          # Maintain dependencies for Swift Package Manager
          - package-ecosystem: "swift"
            directory: "/"
            schedule:
              interval: "weekly"
              day: "monday"
              time: "10:00"
            reviewers:
              - "@lekman"
            labels:
              - "dependencies"
              - "swift"
            commit-message:
              prefix: "chore"
              prefix-development: "chore"
              include: "scope"
            open-pull-requests-limit: 10
        EOF
        
        echo "‚úÖ Created .github/dependabot.yml"
        echo ""
        echo "Dependabot will:"
        echo "   ‚Ä¢ Check for updates weekly (Mondays at 10:00 UTC)"
        echo "   ‚Ä¢ Create PRs with pinned SHA updates"
        echo "   ‚Ä¢ Group all GitHub Actions updates together"
        echo "   ‚Ä¢ Label PRs for easy identification"
        echo ""
        echo "üìù Remember to commit this file to enable Dependabot!"

  security:check-pins:
    desc: Check if all GitHub Actions are properly pinned
    silent: false
    cmds:
      - |
        echo "üîç Checking GitHub Action pins..."
        echo ""
        
        unpinned=0
        
        for file in .github/workflows/*.yml; do
          if [ -f "$file" ]; then
            # Find uses: statements that don't use SHA (40 char hex), excluding commented lines and local actions
            unpinned_actions=$(grep -E "^\s*uses:" "$file" | grep -v "uses: \." | grep -v -E "uses: [^@]+@[0-9a-f]{40}")
            
            if [ -n "$unpinned_actions" ]; then
              echo "‚ùå $(basename "$file") has unpinned actions:"
              echo "$unpinned_actions" | sed 's/^/   /'
              echo ""
              unpinned=$((unpinned + 1))
            fi
          fi
        done
        
        if [ $unpinned -eq 0 ]; then
          echo "‚úÖ All GitHub Actions are properly pinned!"
        else
          echo "‚ö†Ô∏è  Found $unpinned workflow files with unpinned actions"
          echo ""
          echo "Run 'task security:pin-actions' to fix this"
          exit 1
        fi

  security:scan-secrets:
    desc: Scan for secrets and sensitive data
    silent: false
    cmds:
      - |
        echo "üîç Scanning for secrets and sensitive data..."
        echo ""
        
        # Common patterns to check
        patterns=(
          "password.*=.*['\"]" 
          "api[_-]?key.*=.*['\"]"
          "secret.*=.*['\"]"
          "token.*=.*['\"]"
          "private[_-]?key"
          "-----BEGIN.*PRIVATE KEY-----"
          "Bearer\s+[A-Za-z0-9\-_]+"
        )
        
        found_issues=0
        
        # Scan all files except common safe paths
        for pattern in "${patterns[@]}"; do
          results=$(grep -r -i -E "$pattern" . \
            --exclude-dir=.git \
            --exclude-dir=node_modules \
            --exclude-dir=.build \
            --exclude-dir=vendor \
            --exclude="*.lock" \
            --exclude="go.sum" \
            2>/dev/null || true)
          
          if [ -n "$results" ]; then
            echo "‚ö†Ô∏è  Found potential secrets matching pattern: $pattern"
            echo "$results" | head -5
            echo ""
            found_issues=$((found_issues + 1))
          fi
        done
        
        if [ $found_issues -eq 0 ]; then
          echo "‚úÖ No secrets or sensitive data found!"
        else
          echo "‚ùå Found $found_issues potential security issues"
          echo ""
          echo "Please review and remove any sensitive data"
          exit 1
        fi
